<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>愿那颗星星一直指引你</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-08T11:13:11.587Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Karthur</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netty源码解析之服务端创建</title>
    <link href="http://yoursite.com/2020/03/06/Netty%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%88%9B%E5%BB%BA/"/>
    <id>http://yoursite.com/2020/03/06/Netty%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%88%9B%E5%BB%BA/</id>
    <published>2020-03-06T13:51:22.000Z</published>
    <updated>2020-03-08T11:13:11.587Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;一直在想以什么思路去写框架的源码解析比较好，按照我个人的学习经验的话，或许从大到小，从整体到细节，可能会让人比较容易接受一些。所以这第一篇文章，我打算从Netty的服务端初始化开始，剖析以下服务端初始化的过程中做了什么。&lt;/p&gt;
&lt;p&gt;在阅读本文之前，希望大家能掌握NIO的相关知识，最好还有一些Netty的使用经验，这样读起来会容易些。&lt;/p&gt;
    
    </summary>
    
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="原创" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty的线程模型</title>
    <link href="http://yoursite.com/2020/03/02/Netty%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/03/02/Netty%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-03-02T08:48:34.000Z</published>
    <updated>2020-03-06T13:25:18.023Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在开始Netty的源码解析之前，我想了想还是铺垫一下比较好，所以先整一篇Netty的线程模型过渡一下。&lt;/p&gt;
&lt;p&gt;Netty高性能的原因有两方面，其一是它的IO模型，Netty封装了NIO，实现了IO多路复用模型；其二是Netty的线程模型，良好的线程模型设计，能够减少线程上下文切换，减少甚至避免锁的竞争（无锁化设计）带来的开销。&lt;/p&gt;
    
    </summary>
    
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="原创" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Welcome</title>
    <link href="http://yoursite.com/2020/02/28/hello-world/"/>
    <id>http://yoursite.com/2020/02/28/hello-world/</id>
    <published>2020-02-28T12:50:46.705Z</published>
    <updated>2020-03-08T11:14:20.746Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;欢迎来到我的博客！我是Karthur，一名路过的Java工程师……&lt;/p&gt;
&lt;p&gt;这里是我平时写的一些文章，希望能给读者们带来一些帮助，分享一些所学所思～&lt;/p&gt;
&lt;h1 id=&quot;Java并发&quot;&gt;&lt;a href=&quot;#Java并发&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java8中的Stream</title>
    <link href="http://yoursite.com/2020/02/26/Java8%E4%B8%AD%E7%9A%84Stream/"/>
    <id>http://yoursite.com/2020/02/26/Java8%E4%B8%AD%E7%9A%84Stream/</id>
    <published>2020-02-26T08:18:29.000Z</published>
    <updated>2020-03-05T14:25:29.046Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Stream是Java8的一大新特性，其实在以前我也只是听过其大名，也没有好好学一下，因为觉得老语法用的还蛮顺手的。直到最近，参加了阿里巴巴的面试，面试官问我会用Stream吗……那我只能老老实实回答，不大会。。。场面一度有点尴尬（笑），虽然面试结果还行，但是面试官也是建议我有空可以学一下。&lt;/p&gt;
&lt;p&gt;当我学了之后，我不得不好好反思一下，为啥没有push自己去学新的东西呀？！因为这玩意有瘾，用上了就根本停不下来。本文就来简单介绍一下Java中的Stream是怎么回事。&lt;/p&gt;
    
    </summary>
    
    
      <category term="集合" scheme="http://yoursite.com/categories/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="原创" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="集合" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="方法" scheme="http://yoursite.com/tags/%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>这段时间的一些感触</title>
    <link href="http://yoursite.com/2020/02/25/%E8%BF%99%E6%AE%B5%E6%97%B6%E9%97%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E8%A7%A6/"/>
    <id>http://yoursite.com/2020/02/25/%E8%BF%99%E6%AE%B5%E6%97%B6%E9%97%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E8%A7%A6/</id>
    <published>2020-02-25T15:22:33.000Z</published>
    <updated>2020-03-05T15:34:49.203Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;写了一些技术博客，有点想写写自己了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Netty框架下的心跳重连机制实现</title>
    <link href="http://yoursite.com/2020/02/23/%E2%80%9CNetty%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84%E5%BF%83%E8%B7%B3%E9%87%8D%E8%BF%9E%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E2%80%9D/"/>
    <id>http://yoursite.com/2020/02/23/%E2%80%9CNetty%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84%E5%BF%83%E8%B7%B3%E9%87%8D%E8%BF%9E%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E2%80%9D/</id>
    <published>2020-02-23T14:41:46.000Z</published>
    <updated>2020-03-05T08:11:59.381Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在设计到网络通信的项目中，时常要考虑到网络的不稳定性。TCP连接正常情况下断开是需要四次挥手的，当网络突然崩了，包都发不出去，自然就谈不上四次挥手了。此时服务端认为客户端还连着，一直占用的资源就得不到释放。（虽然TCP连接有自带的keep-alive机制，但那时间可是两个小时啊！）&lt;/p&gt;
&lt;p&gt;所谓心跳机制，是定时发送一个自定义的结构体(心跳包)，让对方知道自己还活着，以确保连接的有效性的机制。现在很多的框架以及中间件都用到了心跳检测，比如Spring Cloud中服务注册到Eureka之后会维护一个心跳连接，告诉Eureka自己还活着；Rocket MQ中的Broker和NameSever也会维护一个心跳连接。&lt;/p&gt;
    
    </summary>
    
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="原创" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>NIO中的堆外内存回收——虚引用</title>
    <link href="http://yoursite.com/2020/02/20/NIO%E4%B8%AD%E7%9A%84%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98/"/>
    <id>http://yoursite.com/2020/02/20/NIO%E4%B8%AD%E7%9A%84%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98/</id>
    <published>2020-02-20T15:07:28.000Z</published>
    <updated>2020-03-04T14:44:17.472Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在学习《深入理解Java虚拟机》一书中，我们知道NIO是可以直接使用系统内存（DirectByteBuffer）。而我们知道JVM垃圾回收是无法回收系统的直接内存的，那这块内存用过之后是如何释放的？&lt;/p&gt;
&lt;p&gt;当然肯定不需要我们像C++那样手动释放，这里就要引出Java中最弱的一个引用了——虚引用……&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="原创" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>NIO的三大组件</title>
    <link href="http://yoursite.com/2020/02/19/NIO%E7%9A%84%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/02/19/NIO%E7%9A%84%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6/</id>
    <published>2020-02-19T14:39:46.000Z</published>
    <updated>2020-03-04T11:41:51.741Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;项目中用到Netty比较多，本来想直接写Netty方面的一些文章。但是考虑到Netty本身是对Java NIO的封装，抽象出一个简单易懂的编程模型，所以我觉得还是有必要对一些底层的东西先做一些介绍，不然到时候怕是看的一脸懵逼。&lt;/p&gt;
&lt;p&gt;本文主要是介绍NIO的一些概念，包括其三大组件：Buffer、Channel和Selector，以原理为主。有一说一，NIO使用起来还是蛮复杂的，可能绝大多数情况下我们也接触不到，所以有些地方讲的不到位，请大家见谅。&lt;/p&gt;
&lt;p&gt;阅读本文之前，最好能了解下常见的IO模型，比如：同步阻塞IO，同步非阻塞IO，IO多路复用等等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="IO" scheme="http://yoursite.com/categories/IO/"/>
    
    
      <category term="原创" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>集合中的fail-fast机制</title>
    <link href="http://yoursite.com/2020/02/17/%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84fail-fast%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/02/17/%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84fail-fast%E6%9C%BA%E5%88%B6/</id>
    <published>2020-02-17T14:37:55.000Z</published>
    <updated>2020-03-04T06:27:37.726Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;阿里巴巴Java开发手册中有这样一条规定：不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用&lt;br&gt;Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。&lt;/p&gt;
&lt;p&gt;本文将从源码的角度去解释这条规定。&lt;/p&gt;
    
    </summary>
    
    
      <category term="规范" scheme="http://yoursite.com/categories/%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="原创" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="集合" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="规范" scheme="http://yoursite.com/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList源码解析</title>
    <link href="http://yoursite.com/2020/02/16/ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2020/02/16/ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2020-02-16T14:36:16.000Z</published>
    <updated>2020-03-03T12:43:57.478Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;ArrayList也是一种老生常谈的集合。它的底层数据结构是数组，支持动态扩容。优点是查询速度快，时间效率高；缺点是空间效率不高。我自己在项目中ArrayList用的也挺多的，但是之前也没有看过底层实现，很多理解也只是在停留在表面。想要深入理解，还是得分析源码，从中学习，本文的目的也在于此。&lt;/p&gt;
&lt;p&gt;PS：JDK版本12&lt;/p&gt;
    
    </summary>
    
    
      <category term="集合" scheme="http://yoursite.com/categories/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="原创" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="集合" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码解析</title>
    <link href="http://yoursite.com/2020/02/15/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2020/02/15/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2020-02-15T14:35:56.000Z</published>
    <updated>2020-03-03T12:44:05.211Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;哈希表是一种非常重要的数据结构，应用场景及其丰富。HashMap是Java中的哈希表实现，采用分离链表法解决hash冲突，其底层数据结构为数组+链表/红黑树（JDK1.8后）。其实关于网上关于HashMap的文章确实不少，不过大多感觉有点缺斤少两，有些疑惑的地方也没有解答，就我自己而言可能看了很多篇还是很模糊。所以想了想还是自己写一篇，争取能写的全面点，再加上一些自己的理解，希望能降低下大家的学习成本。&lt;/p&gt;
&lt;p&gt;PS：JDK版本12&lt;/p&gt;
    
    </summary>
    
    
      <category term="集合" scheme="http://yoursite.com/categories/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="原创" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="集合" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>浮点数与BigDecimal</title>
    <link href="http://yoursite.com/2020/02/13/%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8EBigDecimal/"/>
    <id>http://yoursite.com/2020/02/13/%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8EBigDecimal/</id>
    <published>2020-02-13T15:08:34.000Z</published>
    <updated>2020-03-03T10:35:16.699Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在之前写软件的时候出现过这样一种情况，软件界面在显示位移的时候，经常会出现类似于1.9999999964这样子的小数。当时可真是百思不得其解呀，到底问题出在哪？&lt;/p&gt;
&lt;p&gt;后来才知道，我在计算位移的时候使用的浮点数，而浮点数是存在精度损失的。后来我把浮点数换成了BigDecimal，问题就解决了。这篇文章也算是记录下自己所踩的坑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="规范" scheme="http://yoursite.com/categories/%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="原创" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="规范" scheme="http://yoursite.com/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>为什么阿里巴巴手册中禁用默认实现的线程池</title>
    <link href="http://yoursite.com/2020/02/12/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%89%8B%E5%86%8C%E4%B8%AD%E7%A6%81%E7%94%A8%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2020/02/12/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%89%8B%E5%86%8C%E4%B8%AD%E7%A6%81%E7%94%A8%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-02-12T14:38:30.000Z</published>
    <updated>2020-03-03T10:35:01.476Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在阿里巴巴Java开发手册中有一条规则：【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。&lt;/p&gt;
&lt;p&gt;如何去理解这句话？&lt;/p&gt;
    
    </summary>
    
    
      <category term="规范" scheme="http://yoursite.com/categories/%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="原创" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="规范" scheme="http://yoursite.com/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal解析</title>
    <link href="http://yoursite.com/2020/02/11/ThreadLocal%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2020/02/11/ThreadLocal%E8%A7%A3%E6%9E%90/</id>
    <published>2020-02-11T14:34:40.000Z</published>
    <updated>2020-03-03T10:33:27.851Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在之前的几篇文章中，更多的讲的是线程之间的并发操作，多线程在读写共享变量时可能需要进行一些同步操作或者是将变量用volatile修饰等等。如果说每个线程都需要自己的独立实例，且该实例需要在多个方法中被使用（相同线程数据共享），又该如何去实现呢？在方法参数上定义这个共享的变量吗？显然这样子耦合太严重了，牵一发而动全身；那么使用一个全局的集合来共享数据？这又涉及到了多个线程之间的同步问题，只是为了能让线程间隔离数据而使用同步开销太大。&lt;/p&gt;
&lt;p&gt;ThreadLocal就是适用于这样的场景。本文从ThreadLocal的简单使用开始入手，通过源码来阐述其使用原理以及一些隐患。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java并发" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="原创" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Java中的原子基本类型类</title>
    <link href="http://yoursite.com/2020/02/09/Java%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/02/09/Java%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB/</id>
    <published>2020-02-09T14:34:18.000Z</published>
    <updated>2020-03-03T10:34:41.295Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Java从JDK1.5开始提供了java.util.concurrent.atomic包，这个包中当原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。变量的类型有很多，所以Atomic包下一共提供了13个类。本文主要以AtomicInteger为例，以小见大，对它的源码进行剖析，来明白原子类的实现原理。&lt;br&gt;阅读本文前，最好对volatile和CAS有一定了解，这方面可以请看上一篇文章。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java并发" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="原创" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>volatile和CAS</title>
    <link href="http://yoursite.com/2020/02/08/volatile%E5%92%8CCAS/"/>
    <id>http://yoursite.com/2020/02/08/volatile%E5%92%8CCAS/</id>
    <published>2020-02-08T13:51:50.000Z</published>
    <updated>2020-03-03T10:34:25.640Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在讲Java并发编程的时候，volatile关键字和CAS操作都扮演着重要的角色。本文之所以把这两个放在一起讲，是因为两者的有机结合能实现锁的功能。volatile能保证内存可见性和防止重排序，CAS能保证操作的原子性（其实也能保证可见性），两者结合几乎拓展出了整个Java的并发包，Java中Lock的底层实现AQS所依赖的也正是volatile和CAS。&lt;/p&gt;
&lt;p&gt;话不多说，现在让我们一起揭开它们的神秘面纱吧～&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java并发" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="原创" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>synchronized的原理和使用</title>
    <link href="http://yoursite.com/2020/02/05/synchronized%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/05/synchronized%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/</id>
    <published>2020-02-05T10:13:54.000Z</published>
    <updated>2020-03-03T10:34:07.484Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;之前的文章主要结合例子介绍了一些概念性的东西，比如JMM，并发的三大问题等。从本文开始，将陆续介绍一些Java中同步机制。&lt;/p&gt;
&lt;p&gt;本文主要介绍的是Java中的synchronized关键字，从使用入手，慢慢阐述其实现原理以及使用时候等注意事项。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java并发" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="原创" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>内存可见性、原子性和重排序</title>
    <link href="http://yoursite.com/2020/02/03/%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E9%87%8D%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/02/03/%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E9%87%8D%E6%8E%92%E5%BA%8F/</id>
    <published>2020-02-03T14:11:26.000Z</published>
    <updated>2020-03-03T10:33:52.712Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中，笔者简单介绍了下&lt;a href=&quot;https://karthurl.github.io/2020/02/29/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java内存模型&lt;/a&gt;。本文承接上文，主要以代码+图片的形式呈现给大家，其主要目的是让大家对于并发程序中的内存可见性、原子性以及重排序有一定的了解。这三个问题也是并发程序为什么难写的原因。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java并发" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="原创" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="http://yoursite.com/2020/02/02/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/02/02/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/</id>
    <published>2020-02-02T10:29:40.000Z</published>
    <updated>2020-03-02T15:17:25.290Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本文从Java内存模型开始，通过对内存模型的理解让大家对于并发中的内存可见性、原子性和重排序有一些自己的想法，为后续的Java并发编程打下基础。&lt;/p&gt;
&lt;p&gt;阅读本文前，需要有一定的Java基础，最好还有一定的并发编程基础。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java并发" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="原创" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
</feed>
