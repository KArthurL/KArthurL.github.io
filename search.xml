<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Netty源码解析之线程池</title>
    <url>/2020/03/09/Netty%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p>之前有篇文章简单讲了下Netty的线程模型，比较抽象，而本文将从源码的角度去剖析Netty中的线程是怎么设计并运行的。</p>
<a id="more"></a>
<h1 id="NioEventLoopGroup初始化"><a href="#NioEventLoopGroup初始化" class="headerlink" title="NioEventLoopGroup初始化"></a>NioEventLoopGroup初始化</h1><p>Netty中的线程也是需要一个池子来进行统一管理的，我们叫它group。在了解线程的运行机制前，我们先来看一下group干了些什么事，由上而下去剖析。</p>
<p>NioEventLoop是实际的工作线程，是Netty在线程的基础上进行了一次封装，提供了更强大的功能。NioEventLoopGroup则是管理前者的线程池，线程池中的线程就是NioEventLoop。</p>
<p>我们先来看一下NioEventLoopGroup的继承关系，这有助于我们了解其有什么功能：</p>
<p><img src="https://i.loli.net/2020/03/09/z8MnV6lBdkHuIrS.jpg" alt="niogroup.jpg"></p>
<p>可以看到从EventExecutorGroup往上就是JDK提供的并发包内的内容，基础是线程池中可以执行周期任务的线程池服务。所以从这我们可以知道Netty可以实现周期任务，比如心跳检测。这里大家可以暂且不必深究每个类实现什么功能，先往下看。</p>
<p>我们在编写客户端或者服务端的时候，经常会有如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>这就是我们在线程模型里提到的Reactor线程池，我们来看一下NioEventLoopGroup初始化的时候做了什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NioEventLoopGroup中几乎全是重载的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(nThreads, (Executor) <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//最终调用父类MultithreadEventLoopGroup的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, EventExecutorChooserFactory chooserFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">final</span> SelectorProvider selectorProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">final</span> RejectedExecutionHandler rejectedExecutionHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">final</span> EventLoopTaskQueueFactory taskQueueFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(nThreads, executor, chooserFactory, selectorProvider, selectStrategyFactory,</span><br><span class="line">                rejectedExecutionHandler, taskQueueFactory);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最终NioEventLoopGroup的实例化直接调用了父类的构造方法，然后传了一堆参数进去，包括：线程数量、执行器（默认null）、SelectorProvider（这是一个用于创建selecter和Channel的对象）等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">       <span class="comment">//默认线程数位两倍CPU核数</span></span><br><span class="line">       DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>, SystemPropertyUtil.getInt(</span><br><span class="line">               <span class="string">"io.netty.eventLoopThreads"</span>, NettyRuntime.availableProcessors() * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">           logger.debug(<span class="string">"-Dio.netty.eventLoopThreads: &#123;&#125;"</span>, DEFAULT_EVENT_LOOP_THREADS);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//在MultithreadEventLoopGroup的构造方法中，主要是确定了线程的数量</span></span><br><span class="line">   <span class="comment">//如果没有设置，默认是CPU核数的两倍</span></span><br><span class="line">   <span class="comment">//随后调用父类MultithreadEventExecutorGroup的构造方法</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, EventExecutorChooserFactory chooserFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object... args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, chooserFactory, args);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>MultithreadEventLoopGroup的构造方法主要干了一件事，就是确定了线程的数量，随后继续调用父类的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MultithreadEventExecutorGroup的构造方法，略长略长</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nThreads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"nThreads: %d (expected: &gt; 0)"</span>, nThreads));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//由于传入的executor的默认是null，所以使用ThreadPerTaskExecutor</span></span><br><span class="line">            <span class="comment">//这里可以留意以下，待会儿会看到</span></span><br><span class="line">            <span class="comment">//NioEventLoop中的线程就是通过ThreadPerTaskExecutor来创建的</span></span><br><span class="line">            executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建线程数组，数组的数量就是线程数</span></span><br><span class="line">        children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line">        <span class="comment">//开始循环初始化数组中的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//线程的初始化就在这里，需要传入ThreadPerTaskExecutor，待会我们会详细介绍</span></span><br><span class="line">                children[i] = newChild(executor, args);</span><br><span class="line">                success = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"failed to create a child event loop"</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//如果创建失败，则优雅地关闭初始化后的线程</span></span><br><span class="line">                <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                        children[j].shutdownGracefully();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                        EventExecutor e = children[j];</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">while</span> (!e.isTerminated()) &#123;</span><br><span class="line">                                e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException interrupted) &#123;</span><br><span class="line">                            <span class="comment">// Let the caller handle the interruption.</span></span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个线程选择器</span></span><br><span class="line">        chooser = chooserFactory.newChooser(children);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="keyword">new</span> FutureListener&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;</span><br><span class="line">                    terminationFuture.setSuccess(<span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (EventExecutor e: children) &#123;</span><br><span class="line">            e.terminationFuture().addListener(terminationListener);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;EventExecutor&gt; childrenSet = <span class="keyword">new</span> LinkedHashSet&lt;EventExecutor&gt;(children.length);</span><br><span class="line">        Collections.addAll(childrenSet, children);</span><br><span class="line">        readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>抛去一些异常的处理，MultithreadEventExecutorGroup的构造方法主要做了三件事：</p>
<ol>
<li>初始化ThreadPerTaskExecutor来创建线程；</li>
<li>初始化NioEventLoop；</li>
<li>创建线程选择器。</li>
</ol>
<p>前两者后面会讲到，这边先来看一下线程选择器是怎么回事：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里选用了策略模式，根据线程数量的不同，返回不同的选择器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventExecutorChooser <span class="title">newChooser</span><span class="params">(EventExecutor[] executors)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否是2的整数次幂</span></span><br><span class="line">        <span class="keyword">if</span> (isPowerOfTwo(executors.length)) &#123;</span><br><span class="line">            <span class="comment">//如果是</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PowerOfTwoEventExecutorChooser(executors);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果不是</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GenericEventExecutorChooser(executors);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//判断是否是2的整数次幂</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (val &amp; -val) == val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是两种选择器，唯一的不同就在于他们的next()方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerOfTwoEventExecutorChooser</span> <span class="keyword">implements</span> <span class="title">EventExecutorChooser</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger idx = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> EventExecutor[] executors;</span><br><span class="line"></span><br><span class="line">        PowerOfTwoEventExecutorChooser(EventExecutor[] executors) &#123;</span><br><span class="line">            <span class="keyword">this</span>.executors = executors;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//这里用了与运算来快速计算下一条线程的索引</span></span><br><span class="line">            <span class="comment">//看过HashMap源码的读者应该会比较熟悉吧</span></span><br><span class="line">            <span class="keyword">return</span> executors[idx.getAndIncrement() &amp; executors.length - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericEventExecutorChooser</span> <span class="keyword">implements</span> <span class="title">EventExecutorChooser</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger idx = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> EventExecutor[] executors;</span><br><span class="line"></span><br><span class="line">        GenericEventExecutorChooser(EventExecutor[] executors) &#123;</span><br><span class="line">            <span class="keyword">this</span>.executors = executors;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//这里就老老实实取模了</span></span><br><span class="line">            <span class="keyword">return</span> executors[Math.abs(idx.getAndIncrement() % executors.length)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>根据线程数量是否是2的整数次幂，返回不同的线程选择器。</p>
<h1 id="NioEventLoop设计原理"><a href="#NioEventLoop设计原理" class="headerlink" title="NioEventLoop设计原理"></a>NioEventLoop设计原理</h1><p>在开始源码前，有必要先说一下NioEventLoop设计原理，避免看的时候糊里糊涂的。</p>
<p>之前的文章有提到过，NioEventLoop并不是一个纯粹的IO线程，他除了负责IO的读写外，还要处理以下两类任务：</p>
<ul>
<li>系统Task：通过调用NioEventLoop的execute方法实现，Netty有很多的系统Task，创建他们的主要原因是：当IO线程和用户线程同时操作网络资源时，为了防止并发操作导致的锁竞争，将用户线程的操作封装成Task放入任务队列中，有IO线程负责执行，这样就实现了局部无锁化。</li>
<li>定时任务：通过调用NioEventLoop的schedule方法实现。</li>
</ul>
<p>NioEventLoop的继承关系也是十分复杂，我们来看一下：</p>
<p><img src="https://i.loli.net/2020/03/09/ftPxeKM6yAGgiRY.jpg" alt="nioloop.jpg"></p>
<p>NioEventLoop的继承关系相当复杂，而且很多属性以及方法的实现都依赖父类，所以我们需要大体上有个印象。</p>
<h1 id="NioEventLoop初始化"><a href="#NioEventLoop初始化" class="headerlink" title="NioEventLoop初始化"></a>NioEventLoop初始化</h1><p>在NioEventLoopGroup的实例化过程中，调用了其本身的newChild方法来创建NioEventLoop：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> EventLoop <span class="title">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopTaskQueueFactory queueFactory = args.length == <span class="number">4</span> ? (EventLoopTaskQueueFactory) args[<span class="number">3</span>] : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//这里调用了NioEventLoop的构造方法来实例化</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NioEventLoop(<span class="keyword">this</span>, executor, (SelectorProvider) args[<span class="number">0</span>],</span><br><span class="line">            ((SelectStrategyFactory) args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler) args[<span class="number">2</span>], queueFactory);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一下NioEventLoop的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里主要是对SelectorProvider和SelectStrategy进行赋值</span></span><br><span class="line"><span class="comment">//其余的参数通过调用父类的构造方法赋值，不过不是重点</span></span><br><span class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,</span><br><span class="line">                 SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler,</span><br><span class="line">                 EventLoopTaskQueueFactory queueFactory) &#123;</span><br><span class="line">        <span class="keyword">super</span>(parent, executor, <span class="keyword">false</span>, newTaskQueue(queueFactory), newTaskQueue(queueFactory),</span><br><span class="line">                rejectedExecutionHandler);</span><br><span class="line">        <span class="keyword">if</span> (selectorProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"selectorProvider"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (strategy == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"selectStrategy"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        provider = selectorProvider;</span><br><span class="line">        <span class="comment">//重点在这里，这里创建了一个内部类对象SelectorTuple，通过调用openSelector()方法</span></span><br><span class="line">        <span class="keyword">final</span> SelectorTuple selectorTuple = openSelector();</span><br><span class="line">        selector = selectorTuple.selector;</span><br><span class="line">        unwrappedSelector = selectorTuple.unwrappedSelector;</span><br><span class="line">        selectStrategy = strategy;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>NioEventLoop的构造方法除了对一些参数进行赋值之外，还生成了一个内部类对象SelectorTuple，然后从这SelectorTuple中拿到两种selector：JDK原生的unwrappedSelector以及Netty优化过后的selector。接下来我们就继续剖析，Netty底层是如何对selector进行优化的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先来看看这个内部类，其实就俩属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectorTuple</span> </span>&#123;</span><br><span class="line">        <span class="comment">//未优化过的selector</span></span><br><span class="line">        <span class="keyword">final</span> Selector unwrappedSelector;</span><br><span class="line">        <span class="comment">//优化过后的selector</span></span><br><span class="line">        <span class="keyword">final</span> Selector selector;</span><br><span class="line">        SelectorTuple(Selector unwrappedSelector) &#123;</span><br><span class="line">            <span class="keyword">this</span>.unwrappedSelector = unwrappedSelector;</span><br><span class="line">            <span class="keyword">this</span>.selector = unwrappedSelector;</span><br><span class="line">        &#125;</span><br><span class="line">        SelectorTuple(Selector unwrappedSelector, Selector selector) &#123;</span><br><span class="line">            <span class="keyword">this</span>.unwrappedSelector = unwrappedSelector;</span><br><span class="line">            <span class="keyword">this</span>.selector = selector;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//优化的奥秘就在这个openSelctor方法中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SelectorTuple <span class="title">openSelector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Selector unwrappedSelector;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//首先，通过provider拿到一个JDK原生的selector</span></span><br><span class="line">            unwrappedSelector = provider.openSelector();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"failed to open a new selector"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不支持优化selector操作，则直接返回原生的selector</span></span><br><span class="line">        <span class="keyword">if</span> (DISABLE_KEY_SET_OPTIMIZATION) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SelectorTuple(unwrappedSelector);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拿到sun.nio.ch.SelectorImpl的字节码</span></span><br><span class="line">        Object maybeSelectorImplClass = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> Class.forName(</span><br><span class="line">                            <span class="string">"sun.nio.ch.SelectorImpl"</span>,</span><br><span class="line">                            <span class="keyword">false</span>,</span><br><span class="line">                            PlatformDependent.getSystemClassLoader());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cause;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(maybeSelectorImplClass <span class="keyword">instanceof</span> Class) ||</span><br><span class="line">            <span class="comment">// ensure the current selector implementation is what we can instrument.</span></span><br><span class="line">            !((Class&lt;?&gt;) maybeSelectorImplClass).isAssignableFrom(unwrappedSelector.getClass())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maybeSelectorImplClass <span class="keyword">instanceof</span> Throwable) &#123;</span><br><span class="line">                Throwable t = (Throwable) maybeSelectorImplClass;</span><br><span class="line">                logger.trace(<span class="string">"failed to instrument a special java.util.Set into: &#123;&#125;"</span>, unwrappedSelector, t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果获取失败，则返回原生selector</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SelectorTuple(unwrappedSelector);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里优化开始了</span></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; selectorImplClass = (Class&lt;?&gt;) maybeSelectorImplClass;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化一个Netty定义的selectedKeySet，用于替换原生selector中的selectedKeys</span></span><br><span class="line">        <span class="keyword">final</span> SelectedSelectionKeySet selectedKeySet = <span class="keyword">new</span> SelectedSelectionKeySet();</span><br><span class="line"></span><br><span class="line">        Object maybeException = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取原生selector中的selectedKeys属性；</span></span><br><span class="line">                    Field selectedKeysField = selectorImplClass.getDeclaredField(<span class="string">"selectedKeys"</span>);</span><br><span class="line">                    Field publicSelectedKeysField = selectorImplClass.getDeclaredField(<span class="string">"publicSelectedKeys"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//如果JDK版本大于9且支持Unsafe类操作，则使用Unsafe类来进行属性替换</span></span><br><span class="line">                    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">9</span> &amp;&amp; PlatformDependent.hasUnsafe()) &#123;</span><br><span class="line">                        <span class="comment">// Let us try to use sun.misc.Unsafe to replace the SelectionKeySet.</span></span><br><span class="line">                        <span class="comment">// This allows us to also do this in Java9+ without any extra flags.</span></span><br><span class="line">                        <span class="comment">//获取属性的偏移量</span></span><br><span class="line">                        <span class="keyword">long</span> selectedKeysFieldOffset = PlatformDependent.objectFieldOffset(selectedKeysField);</span><br><span class="line">                        <span class="keyword">long</span> publicSelectedKeysFieldOffset =</span><br><span class="line">                                PlatformDependent.objectFieldOffset(publicSelectedKeysField);</span><br><span class="line">                        <span class="comment">//如果获取成功，替换</span></span><br><span class="line">                        <span class="keyword">if</span> (selectedKeysFieldOffset != -<span class="number">1</span> &amp;&amp; publicSelectedKeysFieldOffset != -<span class="number">1</span>) &#123;</span><br><span class="line">                            PlatformDependent.putObject(</span><br><span class="line">                                    unwrappedSelector, selectedKeysFieldOffset, selectedKeySet);</span><br><span class="line">                            PlatformDependent.putObject(</span><br><span class="line">                                    unwrappedSelector, publicSelectedKeysFieldOffset, selectedKeySet);</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// We could not retrieve the offset, lets try reflection as last-resort.</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//由于属性是private的，使用反射设置权限可访问</span></span><br><span class="line">                    Throwable cause = ReflectionUtil.trySetAccessible(selectedKeysField, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> cause;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> cause;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//使用反射进行属性替换</span></span><br><span class="line">                    selectedKeysField.set(unwrappedSelector, selectedKeySet);</span><br><span class="line">                    publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (maybeException <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">            selectedKeys = <span class="keyword">null</span>;</span><br><span class="line">            Exception e = (Exception) maybeException;</span><br><span class="line">            logger.trace(<span class="string">"failed to instrument a special java.util.Set into: &#123;&#125;"</span>, unwrappedSelector, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SelectorTuple(unwrappedSelector);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把selectedkey的引用传递给NioEventLoop的成员变量</span></span><br><span class="line">        selectedKeys = selectedKeySet;</span><br><span class="line">        logger.trace(<span class="string">"instrumented a special java.util.Set into: &#123;&#125;"</span>, unwrappedSelector);</span><br><span class="line">        <span class="comment">//返回优化后的selector</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SelectorTuple(unwrappedSelector,</span><br><span class="line">                                 <span class="keyword">new</span> SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>总的来说，openSelector()方法通过Unsafe或者反射，将JDK原生的Selector中的selectedKeys替换成Netty自己实现的selectedKeySet。</p>
<p>但大家可能会比较迷惑，为什么Netty要对耗费这么多功夫对原生的selector进行优化呢？我们来看一下原生的SelectorImpl和Netty自己实现的SelectedSelectionKeySet：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectorImpl</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSelector</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// The set of keys registered with this Selector</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;SelectionKey&gt; keys;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The set of keys with data ready for an operation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;SelectionKey&gt; selectedKeys;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Public views of the key sets</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;SelectionKey&gt; publicKeys;             <span class="comment">// Immutable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;SelectionKey&gt; publicSelectedKeys;     <span class="comment">// Removal allowed, but not addition</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// used to check for reentrancy</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> inSelect;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">SelectorImpl</span><span class="params">(SelectorProvider sp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(sp);</span><br><span class="line">        keys = ConcurrentHashMap.newKeySet();</span><br><span class="line">        <span class="comment">//重点来了，原生的selectedKeys是HashSet实现。</span></span><br><span class="line">        selectedKeys = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        publicKeys = Collections.unmodifiableSet(keys);</span><br><span class="line">        publicSelectedKeys = Util.ungrowableSet(selectedKeys);</span><br><span class="line">    &#125;</span><br><span class="line">    省略号……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个是Netty自己实现的SelectedSelectionKeySet</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectedSelectionKeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">SelectionKey</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//它虽然继承了AbstractSet，但是底层是数组实现</span></span><br><span class="line">    SelectionKey[] keys;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    SelectedSelectionKeySet() &#123;</span><br><span class="line">        keys = <span class="keyword">new</span> SelectionKey[<span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(SelectionKey o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        keys[size++] = o;</span><br><span class="line">        <span class="keyword">if</span> (size == keys.length) &#123;</span><br><span class="line">            increaseCapacity();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    省略号……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在终于清晰明了了，Netty将原生selectedKeys的HashSet实现，替换成了数组实现。</p>
<p>我们知道当Accept、Read或Write事件发生后，需要将SelectionKey添加到selectedKeys中。HashSet的底层实现是HashMap，极端情况下add方法的时间复杂度O(n)（JDK8以后可能是O(logn)），但是向数组中add元素的时间复杂度是O(1)。</p>
<p>Netty之所以这么做, 其实还是为了性能. 因为这个地方是涉及数据读写的源头, 如果这个地方的性能不高, 会严重影响到程序的性能.可以看到Netty为了提升性能，简直“无所不用其极”（笑）。</p>
<h1 id="NioEventLoop运行机制"><a href="#NioEventLoop运行机制" class="headerlink" title="NioEventLoop运行机制"></a>NioEventLoop运行机制</h1><p>重头戏来了，终于要讲到NioEventLoop的运行机制了。</p>
<p>一路看下来的读者可能会疑惑，好像之前从来没有提到过Netty的线程是如何启动的，跟Java线程的关系也不是很明了，唯一有点关系的就是ThreadPerTaskExecutor这玩意了。</p>
<p>不用担心，接下来我们就来看看Netty中的线程是如何启动的。看过之前那片服务端初始化源码分析的读者可能会有印象，在NioServerSocketChannel的注册任务，是提交给NioEventLoop来执行的，通过调用execute(Runnable runnable)这个方法。事实上，在此之前，NioEventLoop并没有作为一个线程而启动，那么关键就在于这个execute方法上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//值得注意，这个方法的实现是在其父类SingleThreadEventExecutor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"task"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//首先判断添加任务的线程是否就是当前EventLoop中的线程</span></span><br><span class="line">        <span class="comment">//首次提交的时，对象中的Thread为null，始终为false</span></span><br><span class="line">        <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">        <span class="comment">//添加任务到taskQueue中</span></span><br><span class="line">        addTask(task);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">            <span class="comment">//如果不是NioEventLoop内部线程提交的 task，那么判断下线程是否已经启动，没有的话就，启动线程</span></span><br><span class="line">            startThread();</span><br><span class="line">            <span class="comment">//判断是否以及关闭</span></span><br><span class="line">            <span class="keyword">if</span> (isShutdown()) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> reject = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (removeTask(task)) &#123;</span><br><span class="line">                        reject = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedOperationException e) &#123;</span><br><span class="line">                    <span class="comment">// The task queue does not support removal so the best thing we can do is to just move on and</span></span><br><span class="line">                    <span class="comment">// hope we will be able to pick-up the task before its completely terminated.</span></span><br><span class="line">                    <span class="comment">// In worst case we will log on termination.</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (reject) &#123;</span><br><span class="line">                    reject();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">            wakeup(inEventLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//启动线程需要调用startThread方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state == ST_NOT_STARTED) &#123;</span><br><span class="line">            <span class="comment">//通过CAS来保证只有一个线程能帮助NioEventLoop启动</span></span><br><span class="line">            <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//调用doStartThread方法</span></span><br><span class="line">                    doStartThread();</span><br><span class="line">                    success = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                        STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, ST_STARTED, ST_NOT_STARTED);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最终调用doStartThread：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> thread == <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//这个executor是不是就很熟悉了？这个就是ThreadPerTaskExecutor</span></span><br><span class="line">        <span class="comment">//ThreadPerTaskExecutor的execute方法一经调用就会创建一个新的线程Thread</span></span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//重点来了，这里将ThreadPerTaskExecutor创建的线程设置为NioEventLoop的线程</span></span><br><span class="line">                <span class="comment">//至此，NioEventLoop与Thread绑定起来了</span></span><br><span class="line">                thread = Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                    thread.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">                updateLastExecutionTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//执行NioEventLoop的run方法</span></span><br><span class="line">                    SingleThreadEventExecutor.<span class="keyword">this</span>.run();</span><br><span class="line">                    success = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Unexpected exception from an event executor: "</span>, t);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//后面就是进行资源的关闭和释放了，这里先不展开了</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>至此，Java线程的创建以及与NioEventLoop的绑定完成了。</p>
<p>此外，我们还发现一件事，就是无论是用户线程还是其他线程，调用execute方法，最终都会将任务添加进任务队列，不会马上执行。最终任务会有对应的NioEventLoop自身的线程去运行，不存在并发问题，这也是NioEventLoop的无锁化设计，可以避免线程切换和加锁的开销。</p>
<p>线程启动后会执行NioEventLoop中的 run() 方法，此时NioEventLoop终于开始运行了起来，我们来看一下是如何运行的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//NioEventLoop的run方法是一个死循环</span></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//selectSrategy也是之前调用构造方法的时候传入的一个参数，终于派上用场了</span></span><br><span class="line">                   <span class="comment">//暂时可以不必深究其内部原理，只需要知道这里对任务队列进行了一次判断</span></span><br><span class="line">                   <span class="comment">//如果任务队列中有任务，则calculateStrategy方法会调用一次selectNow(),是非阻塞的轮询然后进入default</span></span><br><span class="line">                   <span class="comment">//如果没有队列，则执行SelectStrategy.SELECT分支</span></span><br><span class="line">                   <span class="comment">//总的来说就是根据任务队列中是否有任务来决定select是否阻塞</span></span><br><span class="line">                   <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">                   <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">case</span> SelectStrategy.BUSY_WAIT:</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                       <span class="comment">//这里 select 带阻塞的</span></span><br><span class="line">                       select(wakenUp.getAndSet(<span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                       <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">                           selector.wakeup();</span><br><span class="line">                       &#125;</span><br><span class="line">                     </span><br><span class="line">                   <span class="keyword">default</span>:</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                   rebuildSelector0();</span><br><span class="line">                   handleLoopException(e);</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               cancelledKeys = <span class="number">0</span>;</span><br><span class="line">               needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">               <span class="comment">//这个参数是指IO操作和系统任务时间分配比例</span></span><br><span class="line">               <span class="comment">//默认是50，也就是比例IO操作和系统任务时间分配55开</span></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">               <span class="comment">//如果设置ioRatio为100，那么先执行IO操作然后执行任务</span></span><br><span class="line">               <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="comment">//处理IO事件</span></span><br><span class="line">                       processSelectedKeys();</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                       <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                       <span class="comment">//这里用了try-finally确保任务能执行</span></span><br><span class="line">                       runAllTasks();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">//如果ioRatio不为100，那么根据IO操作耗时，限制系统任务耗时</span></span><br><span class="line">                   <span class="comment">//记录开始前事件</span></span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="comment">//处理IO事件</span></span><br><span class="line">                       processSelectedKeys();</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                       <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                       <span class="comment">//计算系统任务能花多少时间</span></span><br><span class="line">                       <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                       runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">               handleLoopException(t);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// Always handle shutdown even if the loop processing threw an exception.</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (isShuttingDown()) &#123;</span><br><span class="line">                   closeAll();</span><br><span class="line">                   <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">               handleLoopException(t);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>来简单总结下，run方法主要做了两件事：</p>
<ol>
<li>根据任务队列中是否有队列来决定执行selectNow()还是select(oldWakenUp)。如果有任务等待，则使用无阻塞的selectNow()，如果没有任务等待，那就使用带阻塞的select操作。</li>
<li>控制IO操作和系统任务处理的时间分配。主要通过ioRatio参数,如果为100，那么先执行IO操作，然后执行任务队列中的任务；如果不是100，那么先执行IO操作，然后执行taskQueue中的任务，但是需要通过IO操作的耗时和ioRatio参数计算出非IO操作可以占用的事件。</li>
</ol>
<p>至于如何select(oldWakenUp)、processSelectedKeys()方法和runAllTasks(…) 方法的具体实现，这里暂且不深入展开，后续的文章会有相应的例子结合来展示。在本文中，我们只需要理解他们干了啥就行了。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>对于任何架构，线程模型设计的好坏都直接影响软件的性能和并发处理能力。Netty线程模型的设计与实现十分的巧妙，值得我们深入去学习和思考。</p>
<p>本文从NioEventGroup的初始化入手，深入剖析了NioEventLoop的初始化，NioEventLoop与Java线程之间的关系，NioEventLoop是如何做到无锁化设计的以及NioEventLoop的运行机制。文章可能有点晦涩，但是多看几遍，然后对照着源码进行调试，应该还是挺好理解的吧。</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>源码</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty源码解析之服务端创建</title>
    <url>/2020/03/06/Netty%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<p>一直在想以什么思路去写框架的源码解析比较好，按照我个人的学习经验的话，或许从大到小，从整体到细节，可能会让人比较容易接受一些。所以这第一篇文章，我打算从Netty的服务端初始化开始，剖析以下服务端初始化的过程中做了什么。</p>
<p>在阅读本文之前，希望大家能掌握NIO的相关知识，最好还有一些Netty的使用经验，这样读起来会容易些。</p>
<a id="more"></a>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先申明，我使用的Netty版本是<strong>4.1.42.Final</strong>，各个版本的Netty源码或许有些不同，但是流程都是差不多的。</p>
<p>坦白地说，Netty的源码不简单，许多类之间关系错综复杂，代码中的分支也异常的多，在刚开始阅读代码的时候，很容易看着看着跑偏了抓不住主线。所以在本文中，我会抓住主干去叙述，有些分支可能不会深入讲，感兴趣的读者可以自己尝试这调试下。</p>
<p>在阅读过程中推荐读者对照着源码边调试边看。</p>
<h1 id="服务端的初始化"><a href="#服务端的初始化" class="headerlink" title="服务端的初始化"></a>服务端的初始化</h1><p>现在让我们开始吧。</p>
<p>有Netty编程经验的读者应该会知道，Netty的服务端代码还是比较套路的，需要我们开发的主要还是一些Handler，比如下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化服务端</span></span><br><span class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">//配置服务端的线程池，bossGroup负责处理连接事件</span></span><br><span class="line">            <span class="comment">//workerGroup负责处理读写事件</span></span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">                     <span class="comment">//传入用到的Channel，后续通过反射来初始化</span></span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">localAddress</span>(<span class="title">new</span> <span class="title">InetSocketAddress</span>(<span class="title">host</span>,<span class="title">port</span>))</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            socketChannel.pipeline()</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>,<span class="number">60</span>,<span class="number">0</span>, TimeUnit.SECONDS))</span><br><span class="line">                                    .addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder())</span><br><span class="line">                                    .addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder())</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> Shandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">//开始初始化</span></span><br><span class="line">            f = b.bind().sync();</span><br><span class="line">            channel = f.channel();</span><br></pre></td></tr></table></figure>
<p>其实总的来看我们就干了两件事，就是配置服务端，然后启动它。包括服务端所使用的ServerSocketChannel也是通过传入class的方式来灵活配置的。</p>
<p>而配置完成之后，服务端只是把配置记录了下来，真正初始化是在bind()方法，这也是我们本次源码解析的入口。让我们跟进去开一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//对参数进行校验，可以略过</span></span><br><span class="line">    validate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取之前配置的地址参数</span></span><br><span class="line">    SocketAddress localAddress = <span class="keyword">this</span>.localAddress;</span><br><span class="line">    <span class="keyword">if</span> (localAddress == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"localAddress not set"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用doBind方法</span></span><br><span class="line">    <span class="keyword">return</span> doBind(localAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们调用的bind方法中，主要进行了参数的校验和地址参数的获取，最后调用的是对象本身的doBind方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个方法才是真正实现服务端初始化的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//1.初始化Channel并注册</span></span><br><span class="line">        <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">        <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> regFuture;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//如果步骤1已完成</span></span><br><span class="line">        <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">            ChannelPromise promise = channel.newPromise();</span><br><span class="line">            <span class="comment">//2.进行端口绑定并监听</span></span><br><span class="line">            doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">            <span class="keyword">return</span> promise;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//因为步骤1是异步的，有可能到了这里还没完成</span></span><br><span class="line">            <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">            <span class="comment">//添加监听，当事件完成之后再进行绑定</span></span><br><span class="line">            regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    Throwable cause = future.cause();</span><br><span class="line">                    <span class="comment">//在这里要对异步事件进行判断，因为有可能是步骤1发生了异常</span></span><br><span class="line">                    <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        promise.setFailure(cause);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        promise.registered();</span><br><span class="line">                        <span class="comment">//2.进行端口绑定并监听</span></span><br><span class="line">                        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> promise;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到服务端的初始化主要分为两部分，Channel的初始化与注册以及端口的绑定。这两个部分是本文要讲述的重点，至于中间的Promise类，后续会出相关文章介绍，这里就暂时先不展开了。</p>
<h1 id="Channel的初始化与注册"><a href="#Channel的初始化与注册" class="headerlink" title="Channel的初始化与注册"></a>Channel的初始化与注册</h1><p>直接上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//1.新建Channel</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">       <span class="comment">//2.初始化Channel</span></span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(<span class="keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//3.注册Channel到线程池中的线程上</span></span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抛去异常处理的部分不看，这里主要做了三件事：</p>
<ol>
<li>Channel的创建：还记得配置ServerBootStrap的时候传入的NioServerSocketChannel.class吗？就在这里用到了。</li>
<li>Channel的初始化：把一些Handler添加到刚刚创建完成的Channel的PipeLine上。</li>
<li>Channel的注册：把初始化完成的Channel注册到线程池中的某条线程上，后续就由这条线程负责处理连接事件了。</li>
</ol>
<p>下面来仔细分析一下这三部分。</p>
<h2 id="1-Channel的创建"><a href="#1-Channel的创建" class="headerlink" title="1.Channel的创建"></a>1.Channel的创建</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel = channelFactory.newChannel();</span><br></pre></td></tr></table></figure>
<p>Channel的创建使用了工厂方法，这个channelFactory是什么时候创建的？我们来看一下配置NioServerSocketChannel.class的时候发生了什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们配置的时候，调用的是这个方法，传入class对象</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里调用了channelFactory方法，并且初始化了反射工厂作为参数</span></span><br><span class="line">    <span class="comment">//在初始化反射工厂的时候，工厂保存了class对象</span></span><br><span class="line">     <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> ReflectiveChannelFactory&lt;C&gt;(</span><br><span class="line">             ObjectUtil.checkNotNull(channelClass, <span class="string">"channelClass"</span>)</span><br><span class="line">     ));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> B <span class="title">channelFactory</span><span class="params">(io.netty.channel.ChannelFactory&lt;? extends C&gt; channelFactory)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> channelFactory((ChannelFactory&lt;C&gt;) channelFactory);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//最终调用的是这个方法，在这里面将之前初始化的反射工厂赋值给了实例变量channelFactory </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channelFactory</span><span class="params">(ChannelFactory&lt;? extends C&gt; channelFactory)</span> </span>&#123;</span><br><span class="line">     ObjectUtil.checkNotNull(channelFactory, <span class="string">"channelFactory"</span>);</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.channelFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"channelFactory set already"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="comment">//在这里赋值</span></span><br><span class="line">     <span class="keyword">this</span>.channelFactory = channelFactory;</span><br><span class="line">     <span class="keyword">return</span> self();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一下反射工厂对newChannel()是如何创建Channel的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//直接调用构造方法来实例化对象</span></span><br><span class="line">        <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"Unable to create Channel from class "</span> + constructor.getDeclaringClass(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NioServerSocketChannel是Netty为了实现自己的编程模型而将Java NIO中的ServerSocketChannel包装过后的一个类，里面添加了许多属性，包括PipeLine等等，我们来看看它是怎么实例化的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在NioServerSocketChannel中有一个静态变量SelectorProvider</span></span><br><span class="line"><span class="comment">//SelectorProvider是NIO中的一个类，用于生成Selector和Channel的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider();</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是无参构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">//调用重载的构造方法，参数是调用newSocket方法生成的一个nio的ServerSocketChannel</span></span><br><span class="line">        <span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">newSocket</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获得一个nio的ServerSocketChannel并返回</span></span><br><span class="line">            <span class="keyword">return</span> provider.openServerSocketChannel();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(</span><br><span class="line">                    <span class="string">"Failed to open a server socket."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//最终调用了这个构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//调用了父类的构造方法，传入参数值得关注</span></span><br><span class="line">      <span class="comment">//一个是nio的ServerSocketChannel，另一个就很有意思了</span></span><br><span class="line">      <span class="comment">//SelectionKey.OP_ACCEPT，熟悉NIO的话应该知道，这个是Accept事件</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">        config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最终NioServerSocketChannel的初始化会调用父类的构造方法，NioServerSocketChannel的父类是AbstractNioMessageChannel，而在其中要调用了父类的构造方法，所以我们直接来看AbstractNioChannel的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//权限是protected</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="comment">//channel的赋值</span></span><br><span class="line">        <span class="keyword">this</span>.ch = ch;</span><br><span class="line">        <span class="comment">//处理事件的赋值</span></span><br><span class="line">        <span class="keyword">this</span>.readInterestOp = readInterestOp;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//关键来了，nio的ServerSocketChannel设置为非阻塞</span></span><br><span class="line">            ch.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ch.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">                logger.warn(</span><br><span class="line">                            <span class="string">"Failed to close a partially initialized socket."</span>, e2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"Failed to enter non-blocking mode."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>到此，Channel的创建就告一段落了。总的来说，就是通过反射调用NioServerSocketChannel的构造方法实例化，在实例化的过程中，新建了NIO的ServerSocketChannel作为内部的一个属性，同时定义只关心Accept事件，最后设置Channel为非阻塞模式。</p>
<h2 id="2-Channel初始化"><a href="#2-Channel初始化" class="headerlink" title="2.Channel初始化"></a>2.Channel初始化</h2><p>Channel的初始化调用的是<strong>ServerBootstrap</strong>的init()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.socket参数和NioServerSocketChannel的附加属性(如果在配置服务端的时候有配置的话)</span></span><br><span class="line">        setChannelOptions(channel, options0().entrySet().toArray(newOptionArray(<span class="number">0</span>)), logger);</span><br><span class="line">        setAttributes(channel, attrs0().entrySet().toArray(newAttrArray(<span class="number">0</span>)));</span><br><span class="line">      <span class="comment">//获取Channel的PipeLine</span></span><br><span class="line">        ChannelPipeline p = channel.pipeline();</span><br><span class="line">      <span class="comment">//获取workgroup线程池</span></span><br><span class="line">        <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">      <span class="comment">//获取用户定义的Handler</span></span><br><span class="line">        <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">        <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions =</span><br><span class="line">                childOptions.entrySet().toArray(newOptionArray(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(<span class="number">0</span>));</span><br><span class="line">         <span class="comment">//2.这个就很熟悉了，在获取的PipeLine上添加ChannelInitializer</span></span><br><span class="line">        p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123;</span><br><span class="line">               <span class="comment">//在这条Channel初始化之后，会触发这个方法，我们来看看会干啥</span></span><br><span class="line">                <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                ChannelHandler handler = config.handler();</span><br><span class="line">                <span class="comment">//3.将AbstractBootStrap的Handler加上去</span></span><br><span class="line">                <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pipeline.addLast(handler);</span><br><span class="line">                &#125;</span><br><span class="line">                ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                       <span class="comment">//4.这里就比较关键了，把ServerBootstrapAcceptor挂上去</span></span><br><span class="line">                       <span class="comment">//ServerBootstrapAcceptor专门用于处理新来的连接</span></span><br><span class="line">                       <span class="comment">//包括将这些连接的Channel注册到workgroup以及挂上用户自定义的Handler</span></span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Channel初始化的操作比较直接，就几个步骤：1.设置参数；2.挂上一个ChannelInitializer。</p>
<p>这里的ChannelInitializer和ServerBootstrapAcceptor暂时可以不必深究，后面应该会写相应的文章详细解释这两玩意。</p>
<p>现在只差最后一步了，就是Channel的注册。</p>
<h2 id="3-Channel注册"><a href="#3-Channel注册" class="headerlink" title="3.Channel注册"></a>3.Channel注册</h2><p>Channel的注册是在这一行代码，其中group()返回的是之前配置的BossGroup。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ChannelFuture regFuture = config().group().register(channel);</span><br></pre></td></tr></table></figure>
<p>register是一个多态方法，NioEventLoopGroup继承MultithreadEventLoopGroup，所以我们来看一下MultithreadEventLoopGroup中的register方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MultithreadEventLoopGroup中的register方法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//next方法返回group中的一挑EventLoop</span></span><br><span class="line">   <span class="comment">//交由这条线程去完成注册任务</span></span><br><span class="line">     <span class="keyword">return</span> next().register(channel);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SingleThreadEventLoop中的register方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> register(<span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终调用这个方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">     ObjectUtil.checkNotNull(promise, <span class="string">"promise"</span>);</span><br><span class="line">     <span class="comment">//使用Channel中的Unsafe类去完成注册，输入参数包括EventLoop本身</span></span><br><span class="line">     promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</span><br><span class="line">     <span class="keyword">return</span> promise;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>Channel的注册，首先需要选择一条EventLoop与Channel绑定，最终注册的执行还是交由Channel中的Unsafe类来完成的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//AbstractUnsafe中的register方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (eventLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"eventLoop"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isRegistered()) &#123;</span><br><span class="line">                promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">"registered to an event loop already"</span>));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isCompatible(eventLoop)) &#123;</span><br><span class="line">                promise.setFailure(</span><br><span class="line">                        <span class="keyword">new</span> IllegalStateException(<span class="string">"incompatible event loop type: "</span> + eventLoop.getClass().getName()));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在这里，将Channel中的eventloop属性赋值</span></span><br><span class="line">            <span class="comment">//这时候Channel已经归属这条eventLoop管辖了</span></span><br><span class="line">            AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里有一步判断，是否是eventloop线程提交的任务，是Netty无锁化设计的体现</span></span><br><span class="line">            <span class="comment">//如果是则代表没有并发任务，直接执行</span></span><br><span class="line">            <span class="comment">//如果不是则将任务包装成Runnable扔给eventloop中的任务队列</span></span><br><span class="line">            <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">               <span class="comment">//调用register0方法完成注册</span></span><br><span class="line">                register0(promise);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            register0(promise);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.warn(</span><br><span class="line">                            <span class="string">"Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;"</span>,</span><br><span class="line">                            AbstractChannel.<span class="keyword">this</span>, t);</span><br><span class="line">                    closeForcibly();</span><br><span class="line">                    closeFuture.setClosed();</span><br><span class="line">                    safeSetFailure(promise, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//1.调用doRegister方法完成注册</span></span><br><span class="line">                doRegister();</span><br><span class="line">                neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">                registered = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">                safeSetSuccess(promise);</span><br><span class="line">                <span class="comment">//2.传播registered事件</span></span><br><span class="line">                pipeline.fireChannelRegistered();</span><br><span class="line"></span><br><span class="line">               <span class="comment">//判断监听是否成功</span></span><br><span class="line">                <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//3.如果是第一次注册，则传播Active事件</span></span><br><span class="line">                        pipeline.fireChannelActive();</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                        <span class="comment">//4.否则调用beginRead方法</span></span><br><span class="line">                        beginRead();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="comment">// Close the channel directly to avoid FD leak.</span></span><br><span class="line">                closeForcibly();</span><br><span class="line">                closeFuture.setClosed();</span><br><span class="line">                safeSetFailure(promise, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>胜利就在眼前了，register0方法主要做了三件事：</p>
<ol>
<li>调用doRegister()方法完成注册；</li>
<li>传播registered事件；</li>
<li>传播Active事件。</li>
</ol>
<p>来分别看一下，首先是doRegister()方法，这是一个多态方法，具体实现是在AbstractNioChannel中的AbstractNioUnsafe中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//register0方法也是个多态方法，具体实现是在AbstractNioChannel中的AbstractNioUnsafe中</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//这里使用Java NIO底层的SeverSocketChannel去完成注册，并获得SelectionKey，这很重要</span></span><br><span class="line">               <span class="comment">//值得注意的是，第二个参数，注册事件是0</span></span><br><span class="line">                selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">                    <span class="comment">// Force the Selector to select now as the "canceled" SelectionKey may still be</span></span><br><span class="line">                    <span class="comment">// cached and not removed because no Select.select(..) operation was called yet.</span></span><br><span class="line">                    eventLoop().selectNow();</span><br><span class="line">                    selected = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We forced a select operation on the selector before but the SelectionKey is still cached</span></span><br><span class="line">                    <span class="comment">// for whatever reason. JDK bug ?</span></span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>大家可能会觉得奇怪，为什么注册的是0而不是Accept事件呢？这样做的原因有两个：</p>
<ol>
<li>注册方法是多态的，既可以被NioServerSocketChannel用来监听客户端的连接接入，也可以注册SocketChannel用来监听网络读或者写操作；</li>
<li>通过SelectionKey的interestOps（int ops）方法可以方便地修改监听操作位。所以在这里注册成功之后需要获取SelectionKey赋值给AbstractNioChannel的成员变量。</li>
</ol>
<p>注册成功之后就要传播registered事件。当registered事件传递到TailHandler（pipeline的末尾），TailHandler也不关心TailHandler，所以是空实现，就不贴代码了。</p>
<p>最后，根据isActive()方法来判断是否监听成功，如果成功则传播Active事件。fireChannelActive()最终会调用HeadHandler(pipeline的头)的channelActive方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//继续传播Active事件</span></span><br><span class="line">            ctx.fireChannelActive();</span><br><span class="line">            <span class="comment">//判断是否出发读操作</span></span><br><span class="line">            readIfIsAutoRead();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到Head的channelActive方法中除了继续传播Active事件意外，还做了另外件事：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据配置是否觉得是否自动触发Channel的读事件</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readIfIsAutoRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (channel.config().isAutoRead()) &#123;</span><br><span class="line">                channel.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终调用HeadHandler的read方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">            unsafe.beginRead();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">beginRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            assertEventLoop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isActive()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                doBeginRead();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">                invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        pipeline.fireExceptionCaught(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                close(voidPromise());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//doBeginRead也是一个多态方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class="line">        <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</span><br><span class="line">        <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        readPending = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">        <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//修改注册的操作位</span></span><br><span class="line">           <span class="comment">//在这里NioServerSocketChannel将操作位置为OP_ACCEPT</span></span><br><span class="line">            selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最终read方法调用了多态方法doBeginRead，在NioServerSocketChannel的情况下将注册事件改为OP_ACCEPT。</p>
<p>到此，Channel的初始化和注册就完成了，接下来就是端口的绑定。</p>
<h1 id="绑定端口"><a href="#绑定端口" class="headerlink" title="绑定端口"></a>绑定端口</h1><p>绑定端口的操作相对而言就要简单一些了，我们可以从doBind0方法一路追踪下去，最后绕了一圈调用的是NioServerSocketChannel的dobind方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最后调用的事这方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="comment">//使用Java NIO的ServerSocketChannel来完成绑定</span></span><br><span class="line">            javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最后还是通过底层的ServerSocketChannel来完成绑定操作。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>总体来说，沿着Netty服务端的主线分析了一下，Netty服务端初始化做了哪些事情。如果细分的话，主要分为：</p>
<ol>
<li>通过反射创建NioServerSocketChannel；</li>
<li>初始化NioServerSocketChannel，包括设置参数以及添加CHannelInitializer；</li>
<li>将NioServerSocketChannel注册到EventLoop上；</li>
<li>绑定端口。</li>
</ol>
<p>如果有跟踪调试源码的化可以发现，Netty大量的用到了多态，这也是其灵活但是复杂的其中一个原因。我们要搞清楚最终它调用的是哪一个方法。</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>源码</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty的线程模型</title>
    <url>/2020/03/02/Netty%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>在开始Netty的源码解析之前，我想了想还是铺垫一下比较好，所以先整一篇Netty的线程模型过渡一下。</p>
<p>Netty高性能的原因有两方面，其一是它的IO模型，Netty封装了NIO，实现了IO多路复用模型；其二是Netty的线程模型，良好的线程模型设计，能够减少线程上下文切换，减少甚至避免锁的竞争（无锁化设计）带来的开销。</p>
<a id="more"></a>
<h1 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h1><p>说起Netty的线程模型，就不得不提到Reactor模式。</p>
<p>Reactor模式是一种为处理并发服务请求，并将请求提交到一个或者多个服务处理程序的事件设计模式。当客户端请求抵达后，服务处理程序使用多路分配策略，由一个非阻塞的线程来接收所有的请求，然后派发这些请求至相关的工作线程进行处理。我们可以根据下面这张图理解一下：<br><img src="https://i.loli.net/2020/03/06/pwcHEbYOZJzfKgG.jpg" alt="reactor.jpg"></p>
<p>让我们看一下经典的Reactor模型有哪些。</p>
<h2 id="Reactor单线程模型"><a href="#Reactor单线程模型" class="headerlink" title="Reactor单线程模型"></a>Reactor单线程模型</h2><p>首先是Reactor单线程模型，顾名思义，是指所有IO操作都在一个线程上完成，包括：</p>
<ol>
<li>建立TCP连接；</li>
<li>读取通信对端发送过来的消息；</li>
<li>想通信对端发送消息；</li>
</ol>
<p>可以参考这张图：</p>
<p><img src="https://i.loli.net/2020/03/06/Or9I6RyfHjGbMez.png" alt="oreactor.png"></p>
<p>由于一般Reactor模式使用的是非阻塞IO，所有的IO操作都不会导致阻塞，所以理论上一个线程可以独立处理所有IO相关的操作。例如，通过Acceptor接受TCP连接请求，建立连接后通过Dispatch将消息派发到指定的Handler上进行消息的处理等等。</p>
<p>但是，对于高负载、大并发的应用场景下，就不宜使用这种模式了，主要原因如下：</p>
<ol>
<li>一个线程同时处理成千上万的链路，除了处理IO事件外，还要兼顾对消息的处理，性能上无法支撑。</li>
<li>当单个线程处理消息的速度变慢后，会导致大量的客户端连接超时，重发消息，这更加重了IO线程的负载，最终导致大量消息积压和处理超时。</li>
<li>单个线程往往未必可靠，如果意外进入死循环或者挂掉了，那么整个通信系统将变得不可用。</li>
</ol>
<p>为了解决这个问题，后来演进出了多线程模型。</p>
<h2 id="Reactor多线程模型"><a href="#Reactor多线程模型" class="headerlink" title="Reactor多线程模型"></a>Reactor多线程模型</h2><p>一般而言，IO操作中读写事件往往比处理连接事件更加耗时耗资源，因此Reactor多线程模型使用了一组线程（线程池）来处理IO读写事件，用了一个Acceptor线程来专门处理连接事件：</p>
<p><img src="https://i.loli.net/2020/03/06/F3QuWh2AnRweVZL.png" alt="mreactor.png"></p>
<ul>
<li>Acceptor线程：用于监听端口，接受客户端的TCP连接请求。</li>
<li>线程池：用于处理IO读写操作。线程池中的线程负责消息的读取或者发送。一个线程可以同时处理N条链路，但是一个链路只属于一个NIO线程，防止发生并发操作问题。</li>
</ul>
<p>在绝大多数场景下，Reactor多线程模型足够满足性能需求，但在个别特殊的场景中，单个Acceptor可能也会存在性能不足的问题。为了解决这个问题，产生了第三种Reactor模型——Reactor主从多线程模型。</p>
<h2 id="Reactor主从多线程模型"><a href="#Reactor主从多线程模型" class="headerlink" title="Reactor主从多线程模型"></a>Reactor主从多线程模型</h2><p>Reactor主从多线程模型的特点在于，它不再使用单个线程来处理连接请求，而是一个独立的线程池。Acceptor线程池接受到连接请求后，将新创建的SocketChannel注册到IO线程池的某个线程上负责后续的读写事件，如下图所示：</p>
<p><img src="https://i.loli.net/2020/03/06/4lngNZxKjaPGCrt.png" alt="msreactor.png"></p>
<p>使用Reactor主从多线程模型，可以有效解决一个Acceptor线程无法有效处理所有客户端连接的性能不足问题。</p>
<h1 id="Netty中的线程模型"><a href="#Netty中的线程模型" class="headerlink" title="Netty中的线程模型"></a>Netty中的线程模型</h1><p>Netty的线程模型，根据配置的不同，可以使上述的任意一种，官方更推荐Reactor主从多线程模型。</p>
<p>如果有过Netty编程经验的话，在初始化服务端的时候，会新建两个EventLoopGroup。这本质上就是两个线程池，一个负责监听连接请求，一个负责处理IO事件，如下图所示：</p>
<p><img src="https://i.loli.net/2020/03/06/lmGEpcYgrU9HdvF.jpg" alt="Nettythread.png"></p>
<p>Boss Group便是监听端口的线程组，当其接收到连接请求后，初始化Channel并将其注册到Worker Group中的一条EventLoop上。随后这条EventLoop便负责这个连接后续的所有读写事件。</p>
<p>当然，Netty还采用了串行化的设计理念，从消息的读取-&gt;解码-&gt;处理-&gt;编码-&gt;发送，始终由IO线程NioEventLoop负责，而且一个Channel之归属于一条EventLoop。整个流程不会进行线程上下文切换，数据无并发修改风险。此外，Netty的IO线程除了处理IO事件外，还会处理一些系统任务，这个在讲解源码的时候我们会详细说到。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文主要介绍了下Reactor模式及其三种模型和Netty的线程模型，让大家心中对Netty的运行机制有个大概的了解。后续将会是源码解析的文章了，关于这方面我可能要好好规划下怎么写，敬请期待～</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>Netty</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome</title>
    <url>/2020/02/28/hello-world/</url>
    <content><![CDATA[<p>欢迎来到我的博客！我是Karthur，一名路过的Java工程师……</p>
<p>这里是我平时写的一些文章，希望能给读者们带来一些帮助，分享一些所学所思～</p>
<h1 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h1><ol>
<li><a href="https://www.mybulinbulin.cn/2020/02/02/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/" target="_blank" rel="noopener">Java内存模型</a></li>
<li><a href="https://www.mybulinbulin.cn/2020/02/03/%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E9%87%8D%E6%8E%92%E5%BA%8F/" target="_blank" rel="noopener">内存可见性、原子性和重排序</a></li>
<li><a href="https://www.mybulinbulin.cn/2020/02/05/synchronized%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">synchronized的原理和使用</a></li>
<li><a href="https://www.mybulinbulin.cn/2020/02/08/volatile%E5%92%8CCAS/" target="_blank" rel="noopener">volatile和CAS</a></li>
<li><a href="https://www.mybulinbulin.cn/2020/02/09/Java%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB/" target="_blank" rel="noopener">Java中的原子基本类型类</a></li>
<li><a href="https://www.mybulinbulin.cn/2020/02/11/ThreadLocal%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">ThreadLocal解析</a></li>
</ol>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><ol>
<li><a href="https://www.mybulinbulin.cn/2020/02/15/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">HashMap源码解析</a></li>
<li><a href="https://www.mybulinbulin.cn/2020/02/16/ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">ArrayList源码解析</a></li>
<li><a href="https://www.mybulinbulin.cn/2020/02/26/Java8%E4%B8%AD%E7%9A%84Stream/" target="_blank" rel="noopener">Java8中的Stream</a></li>
</ol>
<h1 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h1><ol>
<li><a href="https://www.mybulinbulin.cn/2020/02/19/NIO%E7%9A%84%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6/" target="_blank" rel="noopener">NIO的三大组件</a></li>
</ol>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><ol>
<li><a href="https://www.mybulinbulin.cn/2020/02/20/NIO%E4%B8%AD%E7%9A%84%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98/" target="_blank" rel="noopener">NIO中的堆外内存回收——虚引用</a></li>
</ol>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><ol>
<li><a href="https://www.mybulinbulin.cn/2020/02/23/%E2%80%9CNetty%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84%E5%BF%83%E8%B7%B3%E9%87%8D%E8%BF%9E%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E2%80%9D/" target="_blank" rel="noopener">Netty框架下的心跳重连机制实现</a></li>
<li><a href="https://www.mybulinbulin.cn/2020/03/02/Netty%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">Netty的线程模型</a></li>
<li><a href="https://www.mybulinbulin.cn/2020/03/06/Netty%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%88%9B%E5%BB%BA/" target="_blank" rel="noopener">Netty源码解析之服务端创建</a></li>
<li><a href="https://www.mybulinbulin.cn/2020/03/09/Netty%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/" target="_blank" rel="noopener">Netty源码解析之线程池</a></li>
</ol>
<h1 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h1><ol>
<li><a href="https://www.mybulinbulin.cn/2020/02/12/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%89%8B%E5%86%8C%E4%B8%AD%E7%A6%81%E7%94%A8%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/" target="_blank" rel="noopener">为什么阿里巴巴手册中禁用默认实现的线程池</a></li>
<li><a href="https://www.mybulinbulin.cn/2020/02/13/%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8EBigDecimal/" target="_blank" rel="noopener">浮点数与BigDecimal</a></li>
<li><a href="https://www.mybulinbulin.cn/2020/02/17/%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84fail-fast%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">集合中的fail-fast机制</a></li>
</ol>
<h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><ol>
<li><a href="https://www.mybulinbulin.cn/2020/02/25/%E8%BF%99%E6%AE%B5%E6%97%B6%E9%97%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E8%A7%A6/" target="_blank" rel="noopener">这段时间的一些感触</a></li>
</ol>
<p>大家除了根据分类来寻找文章，也可根据自己的喜好，通过标签来查阅文章，祝大家能有所收获～</p>
]]></content>
  </entry>
  <entry>
    <title>Java8中的Stream</title>
    <url>/2020/02/26/Java8%E4%B8%AD%E7%9A%84Stream/</url>
    <content><![CDATA[<p>Stream是Java8的一大新特性，其实在以前我也只是听过其大名，也没有好好学一下，因为觉得老语法用的还蛮顺手的。直到最近，参加了阿里巴巴的面试，面试官问我会用Stream吗……那我只能老老实实回答，不大会。。。场面一度有点尴尬（笑），虽然面试结果还行，但是面试官也是建议我有空可以学一下。</p>
<p>当我学了之后，我不得不好好反思一下，为啥没有push自己去学新的东西呀？！因为这玩意有瘾，用上了就根本停不下来。本文就来简单介绍一下Java中的Stream是怎么回事。</p>
<a id="more"></a>
<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>在我们平时操作集合的时候，如果需要对集合中对元素进行操作，会怎么做呢？可能会选择for循环遍历元素，然后在循环体中进行操作吧，大概就像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(…)&#123;</span><br><span class="line">    <span class="keyword">if</span>(…)&#123;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要对元素进行更复杂的操作，那么可能循环体里的代码会写的很长很长，可读性就变得非常差。而Stream就可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。</p>
<p>我们先来看一下直观的感受下Stream是如何操作集合并得到我们想要的结果的：<br><img src="https://i.loli.net/2020/03/05/S2nEKkG9JAhlCfm.jpg" alt="stream.jpg"></p>
<p>集合就是Stream的数据来源，整体像流水线一样，中间对元素进行操作，比如：过滤、去重、映射等，最后得到我们想要的结果，比如：集合、最大值、最小值等。</p>
<p>所以到这里大概就可以知道，Stream的使用需要三步：获取Stream，中间操作以及终止操作。</p>
<h1 id="Stream的创建"><a href="#Stream的创建" class="headerlink" title="Stream的创建"></a>Stream的创建</h1><p>在 Java 8 中, 集合接口有两个方法来生成流：</p>
<ul>
<li><p>stream() − 为集合创建串行流。</p>
</li>
<li><p>parallelStream() − 为集合创建并行流。</p>
<h1 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h1><p>对于数据流来说，中间操作符在执行制定处理程序后，数据流依然可以传递给下一级的操作符。中间操作符包含8种：</p>
</li>
</ul>
<ol>
<li>map(mapToInt,mapToLong,mapToDouble)：转换操作符，把比如A-&gt;B，这里默认提供了转int，long，double的操作符。</li>
<li>flatmap(flatmapToInt,flatmapToLong,flatmapToDouble)：拍平操作比如把 int[]{2,3,4} 拍平 变成 2，3，4 也就是从原来的一个数据变成了3个数据，这里默认提供了拍平成int,long,double的操作符。</li>
<li>limit：限流操作，比如数据流中有10个 我只要出前3个就可以使用。</li>
<li>distint：去重操作，对重复元素去重，底层使用了equals方法。</li>
<li>filter：过滤操作，把不想要的数据过滤。</li>
<li>peek：挑出操作，如果想对数据进行某些操作，如：读取、编辑修改等。</li>
<li>skip：跳过操作，跳过某些元素。</li>
<li>sorted(unordered)：排序操作，对元素排序，前提是实现Comparable接口，当然也可以自定义比较器</li>
</ol>
<p>光有这些操作符还不够，因为此时只是记录了操作，数据流还没有真正的动起来，还需最后一步。</p>
<h1 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h1><p>数据经过中间加工操作，就轮到终止操作符上场了；终止操作符就是用来对数据进行收集或者消费的，数据到了终止操作这里就不会向下流动了，终止操作符只能使用一次。终止操作符主要有以下几种：</p>
<ol>
<li>collect 收集操作，将所有数据收集起来，这个操作非常重要，官方的提供的Collectors 提供了非常多收集器，可以说Stream 的核心在于Collectors。</li>
<li>count：统计操作，统计最终的数据个数。</li>
<li>findFirst、findAny：查找操作，查找第一个、查找任何一个，返回的类型为Optional。</li>
<li>noneMatch、allMatch、anyMatch：匹配操作，数据流中是否存在符合条件的元素返回值为boolean值。</li>
<li>min、max：最值操作，需要自定义比较器，返回数据流中最大最小的值。</li>
<li>reduce：规约操作，将整个数据流的值规约为一个值，count、min、max底层就是使用reduce。</li>
<li>forEach、forEachOrdered：遍历操作，这里就是对最终的数据进行消费了。</li>
<li>toArray：数组操作，将数据流的元素转换成数组。</li>
</ol>
<p>到这里Stream的整个使用流程就结束了，可能光介绍不实战还是不够直观。下面就用代码来演示一下。</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">//统计空字符串数量</span></span><br><span class="line">        <span class="keyword">long</span> count = strings.stream()</span><br><span class="line">                                .filter(string-&gt;string.isEmpty())</span><br><span class="line">                                .count();</span><br><span class="line">        System.out.println(<span class="string">"空字符串数量为: "</span> + count);</span><br><span class="line">        <span class="comment">//统计长度=3的数量</span></span><br><span class="line">        count = strings.stream()</span><br><span class="line">                            .filter(string -&gt; string.length() == <span class="number">3</span>)</span><br><span class="line">                            .count();</span><br><span class="line">        System.out.println(<span class="string">"字符串长度为3的数量为: "</span> + count);</span><br><span class="line">        <span class="comment">//合并非空字符串</span></span><br><span class="line">        String mergedString = strings.stream()</span><br><span class="line">                                        .filter(string -&gt;!string.isEmpty())</span><br><span class="line">                                        .collect(Collectors.joining(<span class="string">", "</span>));</span><br><span class="line">        System.out.println(<span class="string">"合并字符串: "</span> + mergedString);</span><br><span class="line">        <span class="comment">//将每个数字平方去重后得到新的集合</span></span><br><span class="line">        List&lt;Integer&gt; squaresList=numbers.stream()</span><br><span class="line">                                            .map( i -&gt;i*i)</span><br><span class="line">                                            .distinct()</span><br><span class="line">                                            .collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">"平方去重: "</span> + squaresList);</span><br><span class="line">        <span class="comment">//获取数组的状态</span></span><br><span class="line">        IntSummaryStatistics stats = numbers.stream()</span><br><span class="line">                                                .mapToInt((x) -&gt;x)</span><br><span class="line">                                                .summaryStatistics();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"列表中最大的数 : "</span> + stats.getMax());</span><br><span class="line">        System.out.println(<span class="string">"列表中最小的数 : "</span> + stats.getMin());</span><br><span class="line">        System.out.println(<span class="string">"所有数之和 : "</span> + stats.getSum());</span><br><span class="line">        System.out.println(<span class="string">"平均数 : "</span> + stats.getAverage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">运行结果：空字符串数量为: <span class="number">2</span></span><br><span class="line">        字符串长度为<span class="number">3</span>的数量为: <span class="number">3</span></span><br><span class="line">        合并字符串: abc, bc, efg, abcd, jkl</span><br><span class="line">        平方去重: [<span class="number">9</span>, <span class="number">4</span>, <span class="number">49</span>, <span class="number">25</span>]</span><br><span class="line">        列表中最大的数 : <span class="number">7</span></span><br><span class="line">        列表中最小的数 : <span class="number">2</span></span><br><span class="line">        所有数之和 : <span class="number">25</span></span><br><span class="line">        平均数 : <span class="number">3.5714285714285716</span></span><br></pre></td></tr></table></figure>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Stream用起来真的太舒服了，真香，不说了我再去用会～</p>
]]></content>
      <categories>
        <category>集合</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>集合</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title>这段时间的一些感触</title>
    <url>/2020/02/25/%E8%BF%99%E6%AE%B5%E6%97%B6%E9%97%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E8%A7%A6/</url>
    <content><![CDATA[<p>&emsp;&emsp;写了一些技术博客，有点想写写自己了。</p>
<a id="more"></a>

<p>&emsp;&emsp;这段时间还是经历了蛮多的，主要是两件事情，一个是终于搭建起了自己的博客啦～也开始陆陆续续的写一些技术文章，虽然好久没写作文了，文笔着实有些不行。第二件事，终于要准备踏上社会了，这段时间参加了不少面试，感触颇深。</p>
<p>&emsp;&emsp;先说说博客吧，其实一直以来就想写博客了，能把自己的所思所学分享给大家其实是一件挺有成就感的事情。只不过由于之前实验室任务的压力和学习压力比较重，只能把一些东西以自己的看得懂的形式记录下来。但是博客呢，不仅要自己懂，还要让别人容易理解，这就挺需要花功夫的。无奈以前时间真的有点紧张，所以一直没有做起来。</p>
<p>&emsp;&emsp;这次特殊时期，我觉得是时候了，因为在家里其实任务压力没那么大，时间也比较充裕，正好趁着这个机会把以前学习的巩固一下，顺便把博客搭起来。于是我的博客就这样诞生了。</p>
<p>&emsp;&emsp;对于这个博客的定位呢，我是想着尽可能多的发一些有营养的文章吧。因为我自己也有经常看别人的博客，但是每次都得花好久去筛选、过滤才能找到一篇还不错的博文。所以在这里，我更多的是想写一些原理性的，源码性质的文章。虽然目前而言现有的这些文章可能深度略有欠缺，不过人是会成长的嘛，相信坚持下去，文章的质量也会越来越高的！</p>
<p>&emsp;&emsp;我个人而言其实对源码非常感兴趣，因为从中可以学到很多比如：编程的规范，模型的设计思路，设计模式的运用等等。但是看源码和写源码分析又是两码事了，可以说是两个层次。光看会了还不行，还得去理解，去分析逻辑，对我一个半路转行的人来说是十分有挑战性的。当然，我还是蛮喜欢这种挑战的(笑)，所以后续我可能会写一些我看过的源码。目前的我暂时的规划是：主要精力用来写一些关于<strong>Netty</strong>的源码解析，毕竟这个框架接触的还蛮多的，而且里面值得学习的地方特别多。虽然估计过程会蛮艰难的，但吃得苦中苦，方为人上人嘛。中间可能穿插着写一些其他文章，比如说<strong>AQS</strong>的源码解析，一些最近学的知识等等。</p>
<p>&emsp;&emsp;另一件事就是找实习了。一直以来我都是自己一个人蒙头蒙脑自学，觉得哪个地方要学就去学啥，从学习路线的规划到资料的获取全靠自己，一路上付出了挺多，踩过不少坑也绕了不少弯路。有时候遇到问题没人能解答，也只能通过上网来解决。所以我挺希望去外面的世界看一看，去大的互联网公司看一看。我自认为智商还算在线，凭我自己的学习能力，在大的平台，我会成长的相当快。</p>
<p>&emsp;&emsp;其实一开始还是没什么自信的，觉得自己好菜呀，所以就投了好些个阿里的部门，想着有一个愿意捞我就不错了，接着就参加了一轮又一轮面试。想起自己人生的第一场面试，真的是紧张的腿发抖，说话都不利索。不过这里得吹一波阿里的面试官们了，都非常奈斯，不会嫌弃你不会，反而会给出一些自己的建议，气氛也没有那么严肃。面着面着，我也渐渐有了自信起来，觉得自己好像也还可以诶，而且目前有两个部门确定走到了交叉面了，也算大大超出了自己的预期。</p>
<p>&emsp;&emsp;其实面试对于我而言，也是一个不可多得的学习机会，因为对面的面试官都是一个个专业人士。令我比较开心的是，一些面试官对我表示肯定，说作为一个非科班生到这个地步，学习能力相当优秀了。甚至有些面试官开始发出邀请，表示希望我能通过后面的面试，这让我受宠若惊。但是，虽然得到了一些肯定，但我还是没有沾沾自喜，因为前面也说到了，“作为一个非科班生”，那么想来我现在离一个科班生还是有一定的差距吧。因此我也会在面试的过程中，向面试官寻求一些学习上的建议，他们也挺乐意指点我一二的，不仅是学习路线上的，比如多看看源码，了解底层等，还有的是思维上的。令我印象比较深刻的是淘系技术部的骨来老师，“我们不要为了用什么而去用什么，学习的顺序和思维的逻辑不能颠倒了，先想明白业务场景，会出现什么问题，再去考虑如何去解决，去优化……”。确实，我开始反思，以前的学习确实很大程度上是为了学啥而学啥，挺少会考虑到为什么要用这个技术。当然除了骨来老师外，还有CBU的乘风老师，中间件的姬风老师等等，都帮了我不少，让我认识到自己的不足。</p>
<p>&emsp;&emsp;希望这次实习之旅能有一个不错的结果吧～</p>
<p>&emsp;&emsp;最后在这里，我还得感谢我最可爱的女朋友晶晶，走到这里少不了她的支持与陪伴。也要感谢某位不知名梁姓大佬，在学习路上的互帮互助，互相鼓励，<a href="https://liangjiacheng.cn/" target="_blank" rel="noopener">他的传送门（笑）</a>。还有各位可爱的群友，比如阿里申，上交大佬，top2大佬等等，我这个菜鸡群主着实上不了台面呀。</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty框架下的心跳重连机制实现</title>
    <url>/2020/02/23/%E2%80%9CNetty%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84%E5%BF%83%E8%B7%B3%E9%87%8D%E8%BF%9E%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E2%80%9D/</url>
    <content><![CDATA[<p>在设计到网络通信的项目中，时常要考虑到网络的不稳定性。TCP连接正常情况下断开是需要四次挥手的，当网络突然崩了，包都发不出去，自然就谈不上四次挥手了。此时服务端认为客户端还连着，一直占用的资源就得不到释放。（虽然TCP连接有自带的keep-alive机制，但那时间可是两个小时啊！）</p>
<p>所谓心跳机制，是定时发送一个自定义的结构体(心跳包)，让对方知道自己还活着，以确保连接的有效性的机制。现在很多的框架以及中间件都用到了心跳检测，比如Spring Cloud中服务注册到Eureka之后会维护一个心跳连接，告诉Eureka自己还活着；Rocket MQ中的Broker和NameSever也会维护一个心跳连接。</p>
<a id="more"></a>
<h1 id="Netty提供的工具"><a href="#Netty提供的工具" class="headerlink" title="Netty提供的工具"></a>Netty提供的工具</h1><p>Netty中提供了IdleStateHandler，我们可以使用这个工具来实现心跳机制。</p>
<p>IdleStateHandler作用：当channel在指定时间内没有触发read，write会触发相应的IdleStateEvent事件，并传递给下一个Handler。所以使用的时候将IdleStateHandler放在入站的开头，重写后面Handler的userEventTriggered这个方法来处理对应的事件。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>先来捋一下设计思路：</p>
<ol>
<li>客户端的ChannelPipeline中加入IdleStateHandler，设置一下客户端的读空闲时间，例如5s；</li>
<li>客户端的IdleStateHandler中5s内没有触发read方法，就会触发IdleStateEvent事件并进行传播；</li>
<li>客户端的userEventTriggered方法中发送心跳包给服务端，检测服务端是否存活，避免服务端已经宕机但客户端还不知道的情况发生；</li>
<li>服务端收到心跳包后对客户端作出回应；</li>
<li>服务端的ChannelPipeline中加入IdleStateHandler，设置一下服务端的写空闲时间，例如60s；</li>
<li>如果服务端内60s内没有收到心跳包，则说明客户端出现故障，此时将该连接关闭。</li>
</ol>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="服务端编码"><a href="#服务端编码" class="headerlink" title="服务端编码"></a>服务端编码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="keyword">private</span> String host=<span class="string">"127.0.0.1"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        ChannelFuture f = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//ServerBootstrap负责初始化netty服务器，并且开始监听端口的socket请求</span></span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">localAddress</span>(<span class="title">new</span> <span class="title">InetSocketAddress</span>(<span class="title">host</span>,<span class="title">port</span>))</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">// 为监听客户端read/write事件的Channel添加用户自定义的ChannelHandler</span></span><br><span class="line">                            socketChannel.pipeline()</span><br><span class="line">                                    <span class="comment">//这里我们设置IdleStateHandler的写空闲时间为60s，并置于入站头</span></span><br><span class="line">                                    <span class="comment">//因为收到心跳包会响应，所以这里读或写事件差别不大</span></span><br><span class="line">                                    .addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>,<span class="number">60</span>,<span class="number">0</span>, TimeUnit.SECONDS))</span><br><span class="line">                                    .addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder())</span><br><span class="line">                                    .addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder())</span><br><span class="line">                                    <span class="comment">//自己定义的handler</span></span><br><span class="line">                                    .addLast(<span class="keyword">new</span> Shandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">//启动服务端绑定端口</span></span><br><span class="line">            f = b.bind().sync();</span><br><span class="line">            channel = f.channel();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的handler</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        ctx.writeAndFlush(<span class="string">"back"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(evt <span class="keyword">instanceof</span> IdleStateEvent)&#123;</span><br><span class="line">            IdleState idleState=((IdleStateEvent)evt).state();</span><br><span class="line">            <span class="comment">//如果是写事件，则说明已经超过60s没有收到心跳包了</span></span><br><span class="line">            <span class="keyword">if</span>(idleState==IdleState.WRITER_IDLE)&#123;</span><br><span class="line">                System.out.println(<span class="string">"超时关闭"</span>);</span><br><span class="line">                <span class="comment">//关闭连接</span></span><br><span class="line">                ctx.close();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.userEventTriggered(ctx,evt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" 连接成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这里是服务端，断开连接"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端思路蛮简单的，收到心跳包回复，超过60s没收到心跳包断开连接</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span>  Channel channel=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Bootstrap b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//ServerBootstrap负责初始化netty服务器，并且开始监听端口的socket请求</span></span><br><span class="line">            b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            b.group( workerGroup)</span><br><span class="line">                    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            socketChannel.pipeline()</span><br><span class="line">                                    <span class="comment">//这里我们设置IdleStateHandler的读空闲时间为5s，并置于入站头</span></span><br><span class="line">                                    .addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>, TimeUnit.SECONDS))</span><br><span class="line">                                    .addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder())</span><br><span class="line">                                    .addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder())</span><br><span class="line">                                    <span class="comment">//加入自定义客户端handler</span></span><br><span class="line">                                    .addLast(<span class="keyword">new</span> Chandler(Client.<span class="keyword">this</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      ChannelFuture  f = b.connect(<span class="string">"127.0.0.1"</span>,<span class="number">9900</span>).sync();</span><br><span class="line">        channel = f.channel();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Client client=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chandler</span><span class="params">(Client client)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client=client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个统计变量，如果超过一定数量的心跳包没有收到回复，则认为网络出了问题，采取重连策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        <span class="comment">//收到服务端消息，变量清零</span></span><br><span class="line">        x=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(evt <span class="keyword">instanceof</span> IdleStateEvent)&#123;</span><br><span class="line">            IdleState idleState=((IdleStateEvent)evt).state();</span><br><span class="line">            <span class="comment">//超过5s没有收到读事件</span></span><br><span class="line">            <span class="keyword">if</span>(idleState==IdleState.READER_IDLE)&#123;</span><br><span class="line">                <span class="comment">//如果小于五次，继续发送心跳包</span></span><br><span class="line">                <span class="keyword">if</span>(x&lt;<span class="number">5</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"心跳"</span> + x);</span><br><span class="line">                    x++;</span><br><span class="line">                    ctx.writeAndFlush(<span class="string">"heart"</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//大于五次就重连了</span></span><br><span class="line">                    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            client.close();</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                               client.connect();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).start();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.userEventTriggered(ctx,evt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"客户端连接成功"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"客户端断开连接"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端空闲时间每隔5s发送心跳包，超过5次没有收到回复，则采取重连策略。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>所谓的心跳, 即在TCP长连接中，客户端和服务器之间定期发送的一种特殊的数据包，通知对方自己还在线，以确保TCP连接的有效性。因为网络的不可靠性，有可能在TCP保持长连接的过程中，由于某些突发情况，例如网线被拔出，突然掉电等，会造成服务器和客户端的连接中断。在这些突发情况下，如果恰好服务器和客户端之间没有交互的话，那么它们是不能在短时间内发现对方已经掉线的。为了解决这个问题，我们就需要引入心跳机制。Netty框架的功能相当强大的，使用Netty实现心跳检测还是比较简单的。不过具体使用需要结合业务场景来采取不同的心跳措施。</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>Netty</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>NIO中的堆外内存回收——虚引用</title>
    <url>/2020/02/20/NIO%E4%B8%AD%E7%9A%84%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<p>在学习《深入理解Java虚拟机》一书中，我们知道NIO是可以直接使用系统内存（DirectByteBuffer）。而我们知道JVM垃圾回收是无法回收系统的直接内存的，那这块内存用过之后是如何释放的？</p>
<p>当然肯定不需要我们像C++那样手动释放，这里就要引出Java中最弱的一个引用了——虚引用……</p>
<a id="more"></a>
<h1 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h1><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，且无法通过虚引用来获得一个对象的实例。那么虚引用出现的意义是什么呢？</p>
<p>虚引用的作用在于跟踪垃圾回收过程，在对象被收集器回收时收到一个系统通知。 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，将这个虚引用加入引用队列，在其关联的虚引用出队前，不会彻底销毁该对象。 所以可以通过检查引用队列中是否有相应的虚引用来判断对象是否已经被回收了。所以虚引用的使用必须和引用队列一起使用。我们来看下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//新建引用队列</span></span><br><span class="line">        ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">        Object o=<span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">//新建虚引用</span></span><br><span class="line">        PhantomReference&lt;Object&gt; phantomReference=<span class="keyword">new</span> PhantomReference&lt;&gt;(o,queue);</span><br><span class="line">        System.out.println(phantomReference);</span><br><span class="line">        <span class="comment">//垃圾回收这个对象</span></span><br><span class="line">        o=<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//调用垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        Reference x=queue.poll();</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">运行结果：java.lang.ref.PhantomReference@<span class="number">1f</span>b3ebeb</span><br><span class="line">        java.lang.ref.PhantomReference@<span class="number">1f</span>b3ebeb</span><br></pre></td></tr></table></figure>
<p>可以看到引用队列里的正是我们之前定义的那个虚引用。了解了这个之后，我们再来看看堆外内存是如何通过虚引用来实现自动释放的。</p>
<h1 id="堆外内存的创建"><a href="#堆外内存的创建" class="headerlink" title="堆外内存的创建"></a>堆外内存的创建</h1><p>我们先从堆外内存的创建入手，看看在堆外内存初始化的时候做了什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123;                  </span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line">    <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里使用了Unsafe类中的方法直接开辟内存，调用的是native方法</span></span><br><span class="line">        base = UNSAFE.allocateMemory(size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    UNSAFE.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//记录内存的地址，待会释放内存的时候会用到</span></span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这一步很关键，创建一个cleaner对象，依靠这个对象来完成内存释放</span></span><br><span class="line">    cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span><br><span class="line">    att = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化堆外内存的时候主要干了三件事：</p>
<ol>
<li>调用native方法开辟内存</li>
<li>记录内存的地址</li>
<li>创建一个Cleanr对象</li>
</ol>
<p>这个Clean对象就是本文的重点。</p>
<h1 id="堆外内存的回收"><a href="#堆外内存的回收" class="headerlink" title="堆外内存的回收"></a>堆外内存的回收</h1><p>找到自动回收的重点了，就是这个Cleaner，我们来看看它是个啥：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cleaner</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">PhantomReference</span>&lt;<span class="title">Object</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//创建<span class="title">Cleaner</span>的时候传入持有的对象以及一个任务</span></span><br><span class="line"><span class="class"><span class="title">private</span> <span class="title">Cleaner</span>(<span class="title">Object</span> <span class="title">referent</span>, <span class="title">Runnable</span> <span class="title">thunk</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//调用虚引用的构造函数，传入对象以及Cleaner内部的静态引用队列</span></span><br><span class="line">        <span class="keyword">super</span>(referent, dummyQueue);</span><br><span class="line">        <span class="keyword">this</span>.thunk = thunk;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Cleaner对象继承了虚引用，并且在实例化的时候会传入一个任务。在之前的代码中，我们看到传入的参数一个是DirectByteBuffer对象本身，一个是Deallocator。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Deallocator实现了Runnable接口</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Deallocator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Deallocator</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> size, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (address != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//run方法中实现了内存的释放</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Paranoia</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//就是在这里，调用native方法释放了内存</span></span><br><span class="line">        UNSAFE.freeMemory(address);</span><br><span class="line">        address = <span class="number">0</span>;</span><br><span class="line">        Bits.unreserveMemory(size, capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在终于找到了自动释放内存的方法了，就是这个Deallocator任务。那么最后一个问题，什么时候会运行这任务？我们来看顶层的引用抽象类Reference中的一段方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在Reference类的静态方法中，会开启一个守护线程</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class="line">        <span class="keyword">for</span> (ThreadGroup tgn = tg;</span><br><span class="line">             tgn != <span class="keyword">null</span>;</span><br><span class="line">             tg = tgn, tgn = tg.getParent());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启一个守护线程</span></span><br><span class="line">        Thread handler = <span class="keyword">new</span> ReferenceHandler(tg, <span class="string">"Reference Handler"</span>);</span><br><span class="line">        <span class="comment">/* If there were a special system-only priority greater than</span></span><br><span class="line"><span class="comment">         * MAX_PRIORITY, it would be used here</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        handler.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        handler.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        handler.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// provide access in SharedSecrets</span></span><br><span class="line">        SharedSecrets.setJavaLangRefAccess(<span class="keyword">new</span> JavaLangRefAccess() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">waitForReferenceProcessing</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Reference.waitForReferenceProcessing();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runFinalization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Finalizer.runFinalization();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这类一直运行在后台，用来处理引用类型的任务</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ensureClassInitialized</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class.forName(clazz.getName(), <span class="keyword">true</span>, clazz.getClassLoader());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (Error) <span class="keyword">new</span> NoClassDefFoundError(e.getMessage()).initCause(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// pre-load and initialize Cleaner class so that we don't</span></span><br><span class="line">            <span class="comment">// get into trouble later in the run loop if there's</span></span><br><span class="line">            <span class="comment">// memory shortage while loading/initializing it lazily.</span></span><br><span class="line">            ensureClassInitialized(Cleaner<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class="line">            <span class="keyword">super</span>(g, <span class="keyword">null</span>, name, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//一直在运行这方法</span></span><br><span class="line">                processPendingReferences();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>接着往下看这守护线程调用的方法是什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processPendingReferences</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    waitForReferencePendingList();</span><br><span class="line">    Reference&lt;Object&gt; pendingList;</span><br><span class="line">    <span class="keyword">synchronized</span> (processPendingLock) &#123;</span><br><span class="line">        pendingList = getAndClearReferencePendingList();</span><br><span class="line">        processPendingActive = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pendingList != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Reference&lt;Object&gt; ref = pendingList;</span><br><span class="line">        pendingList = ref.discovered;</span><br><span class="line">        ref.discovered = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重点来了，在这个地方，判断拿出来的引用是不是Cleaner</span></span><br><span class="line">        <span class="keyword">if</span> (ref <span class="keyword">instanceof</span> Cleaner) &#123;</span><br><span class="line">            <span class="comment">//调用Cleaner的clean方法</span></span><br><span class="line">            ((Cleaner)ref).clean();</span><br><span class="line">            <span class="comment">// Notify any waiters that progress has been made.</span></span><br><span class="line">            <span class="comment">// This improves latency for nio.Bits waiters, which</span></span><br><span class="line">            <span class="comment">// are the only important ones.</span></span><br><span class="line">            <span class="keyword">synchronized</span> (processPendingLock) &#123;</span><br><span class="line">                processPendingLock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ReferenceQueue&lt;? <span class="keyword">super</span> Object&gt; q = ref.queue;</span><br><span class="line">            <span class="keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(ref);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Notify any waiters of completion of current round.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (processPendingLock) &#123;</span><br><span class="line">        processPendingActive = <span class="keyword">false</span>;</span><br><span class="line">        processPendingLock.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现重点了，当我们发现Cleaner被回收了，也就说明DirectByteBuffer也被回收了，此时调用clean方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Cleaner的clean方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!remove(<span class="keyword">this</span>))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在这里调用了thunk的run方法，thunk也就是之前传进来的Deallocator任务</span></span><br><span class="line">        thunk.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable x) &#123;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (System.err != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">new</span> Error(<span class="string">"Cleaner terminated abnormally"</span>, x)</span><br><span class="line">                            .printStackTrace();</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，真相大白了。在堆外内存创建的过程中，会在堆内中生成一个虚引用，然后虚引用中有一个address指向了堆外内存中，并且注册了一个Clean类，在其中有unsafe释放堆外内存的方法。JVM在GC的过程中，会回收堆内的虚引用。虚引用执行完自己的finalize方法后，会把自己挂到ReferenceQueue中，然后，守护线程会调用其clean方法，释放内存。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>使用虚引用的目的就是为了得知对象被GC的时机，所以可以利用虚引用来进行销毁前的一些操作，比如说资源释放等。这个虚引用对于对象而言完全是无感知的，有没有完全一样，但是对于虚引用的使用者而言，可以通过它来观察对象是否已经被回收，从而进行相应的处理。堆外内存的回收正是依靠的这一个特点。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>源码</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>NIO的三大组件</title>
    <url>/2020/02/19/NIO%E7%9A%84%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>项目中用到Netty比较多，本来想直接写Netty方面的一些文章。但是考虑到Netty本身是对Java NIO的封装，抽象出一个简单易懂的编程模型，所以我觉得还是有必要对一些底层的东西先做一些介绍，不然到时候怕是看的一脸懵逼。</p>
<p>本文主要是介绍NIO的一些概念，包括其三大组件：Buffer、Channel和Selector，以原理为主。有一说一，NIO使用起来还是蛮复杂的，可能绝大多数情况下我们也接触不到，所以有些地方讲的不到位，请大家见谅。</p>
<p>阅读本文之前，最好能了解下常见的IO模型，比如：同步阻塞IO，同步非阻塞IO，IO多路复用等等。</p>
<a id="more"></a>
<h1 id="NIO简介"><a href="#NIO简介" class="headerlink" title="NIO简介"></a>NIO简介</h1><p>Java NIO是JDK1.4之后提供的一套新的IO API，它主要实现了两套IO模型，不使用Selector的时候是同步非阻塞IO；在网络编程中使用Selector，是IO多路复用模型。相比于之前的Java BIO，除了IO模型之外，有一个很大的不同点在于，NIO是面向块(Buffer)和通道(Channel)的，而BIO是面向流(Stream)的。NIO中的通道是双向的，既可以写也可以读；但是BIO的流是单向的，分为OutputStream和InputStream。</p>
<p>NIO的读写示意图如下：</p>
<p><img src="https://i.loli.net/2020/03/04/p24mfNeZlaJOCo5.jpg" alt="NIO.jpg"></p>
<p>用户直接操作的是Buffer，而读写操作都需要将数据从Channel拷贝到Buffer或者将数据从Buffer写入Channel中。</p>
<h1 id="NIO：Buffer"><a href="#NIO：Buffer" class="headerlink" title="NIO：Buffer"></a>NIO：Buffer</h1><p>Buffer本质上是一块内存，也是我们编程时直接操作的对象。</p>
<p>Java中主要定义了以下几个Buffer的实现：</p>
<p><img src="https://i.loli.net/2020/03/04/k45hPMWN3IRByfV.jpg" alt="buffer.jpg"></p>
<p>比较核心的还是ByteBuffer，其他的Buffer类，只是包装了一下它而已，我们使用最多的通常也是 ByteBuffer。ByteBuffer还分为堆内的Buffer和堆外的Buffer，前者是受JVM管制的，后者是通过native方法调用的系统直接内存，不过这不是本文的重点，后续可能会有相关文章讲解这个。</p>
<p>收回来，从某种意义上来讲，Buffer很像是一个数组，不同类型的Buffer就好比byte[], int[]等，只不过操作Buffer要复杂的多。</p>
<h2 id="Buffer中的指针操作"><a href="#Buffer中的指针操作" class="headerlink" title="Buffer中的指针操作"></a>Buffer中的指针操作</h2><p>在顶层的抽象类Buffer中，存在着三个指针，分别是position、limit和capacity，以及一个标记mark：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mark = -<span class="number">1</span>;       <span class="comment">//用于标记position位置，复位时使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;    <span class="comment">//写操作下代表下一个写数据的位置，读操作下代表下一个读数据的位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> limit;           <span class="comment">//写操作下代表最大能写入数据的位置，读操作下代表最大可读数据的位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;        <span class="comment">//Buffer的容量，初始化完成之后就不可变了</span></span><br></pre></td></tr></table></figure>
<p>注释可能说的不够清晰，看图就比较直观了：</p>
<p><img src="https://i.loli.net/2020/03/04/Z5dhByr3IzCPkjF.jpg" alt="pos.jpg"></p>
<p>所以读写模式的切换，也只不过是指针的切换而已，后面会说到。</p>
<h2 id="Buffer初始化"><a href="#Buffer初始化" class="headerlink" title="Buffer初始化"></a>Buffer初始化</h2><p>初始化Buffer相当简单，每一个Buffer实现类都会提供一个静态方法allocate(int capacity)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> createCapacityException(capacity);</span><br><span class="line">        <span class="comment">//根据参数实例化Buffer</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(capacity, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者调用静态方法wrap，输入已有的数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> wrap(array, <span class="number">0</span>, array.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(array, offset, length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException x) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Buffer的读写"><a href="#Buffer的读写" class="headerlink" title="Buffer的读写"></a>Buffer的读写</h2><h3 id="写Buffer"><a href="#写Buffer" class="headerlink" title="写Buffer"></a>写Buffer</h3><p>写Buffer主要有两种，一种是我们手动填充Buffer，一种是从Channel中把数据写入Buffer中（在系统层面上，这个操作我们称为读操作）。</p>
<ul>
<li>手动填充Buffer：调用Buffer提供给我们的put()方法手动填充，但是这些方法需要我们在编程的时候注意控制数据和Buffer的大小，否则一旦数据溢出会抛出java.nio.BufferOverflowException异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按顺序填充一个byte值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> b)</span></span>;</span><br><span class="line"><span class="comment">// 在指定位置填充一个byte值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span> b)</span></span>;</span><br><span class="line"><span class="comment">// 将一个数组填充进去</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src)</span> </span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>从Channel获取数据：这一步而言无需我们考虑太多，因为NIO底层以及帮我们实现好了，只需要调用Channel.read（Buffer buf）即可，返回可读数据的大小。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = channel.read(buf);</span><br></pre></td></tr></table></figure>

<h3 id="读Buffer"><a href="#读Buffer" class="headerlink" title="读Buffer"></a>读Buffer</h3><p>读Buffer同样也有两种，一种是我们从Buffer中读取数据，一种是将数据写入到Channel中（在系统层面上，这个操作我们称为写操作）。<br>在写入模式下是无法进行读操作的，因为指针的问题，前面也说到了。我们需要调用Buffer的flip()方法，将Buffer从写入模式切换到读取模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个方法将指针切换了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position; <span class="comment">// 将limit设置为position</span></span><br><span class="line">    position = <span class="number">0</span>;     <span class="comment">// 将position置为0</span></span><br><span class="line">    mark = -<span class="number">1</span>;        <span class="comment">// mark恢复默认值-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>手动读取Buffer：调用Buffer提供的get()方法手动获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 position 来获取数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取指定位置的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="comment">// 将Buffer中的数据写入到数组中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将数据写入Channel：调用Channel.write(Buffer buf)即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = channel.write(buf);</span><br></pre></td></tr></table></figure>
<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><h3 id="标记复位"><a href="#标记复位" class="headerlink" title="标记复位"></a>标记复位</h3><p>之前有提到，Buffer还有一个标记mark。mark用于记录当前的position位置，当我们想从标记位开始重新读数据时，使用reset()方法将position恢复到mark位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Buffer <span class="title">mark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//标记position位置</span></span><br><span class="line">    mark = position;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Buffer <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = mark;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</span><br><span class="line">    <span class="comment">//复位position到mark</span></span><br><span class="line">    position = m;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重置Buffer"><a href="#重置Buffer" class="headerlink" title="重置Buffer"></a>重置Buffer</h3><p>当我们读完Buffer之后想要再次写入Buffer，我们需要把Buffer清空。Buffer主要提供了以下几个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只将position置0，用于重新从头读写Buffer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相当于重新实例化了Buffer，但是Buffer里的数据没有删除，一般用于读取完Buffer后重新写入数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比较特殊，会讲还未读取的数据一到左边，在这个基础上开始写入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">compact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.arraycopy(hb, ix(position()), hb, ix(<span class="number">0</span>), remaining());</span><br><span class="line">        position(remaining());</span><br><span class="line">        limit(capacity());</span><br><span class="line">        discardMark();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="NIO：Channel"><a href="#NIO：Channel" class="headerlink" title="NIO：Channel"></a>NIO：Channel</h1><p>Channel是NIO中的第二个件，虽然离我们之间隔了一个Buffer，但是所有的数据来源和目的地都是Channel。Channel的种类也十分多，根据数据的来源或者使用方式不同，主要包括以下几种：</p>
<ol>
<li>FileChannel：文件通道，用于文件的读和写</li>
<li>DatagramChannel：用于UDP连接的接收和发送</li>
<li>SocketChannel：把它理解为TCP连接通道，简单理解就是TCP客户端</li>
<li>ServerSocketChannel：TCP对应的服务端，用于监听某个端口进来的请求</li>
</ol>
<p>在说到NIO的时候，我们更多的关注点在SocketChannel和ServerSocketChannel上，包括常用的网络通信框架Netty中的Channel也是封装的这两个。</p>
<p>这两个的用法也蛮简单的，如果有网络编程经验的话，挺好理解的应该。</p>
<h2 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先打开一个通道</span></span><br><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line"><span class="comment">// 向目标地址端口发起连接</span></span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"https://www.mybulinbulin.cn/"</span>, <span class="number">80</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取数据到Buffer中</span></span><br><span class="line">socketChannel.read(buffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入数据</span></span><br><span class="line">socketChannel.write(buffer);</span><br></pre></td></tr></table></figure>

<h2 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先打开一个通道</span></span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">// 绑定8080端口并开启监听</span></span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 一旦有一个 TCP 连接进来，就创建一个SocketChannel进行处理</span></span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后续处理，省略号……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="NIO：Selector"><a href="#NIO：Selector" class="headerlink" title="NIO：Selector"></a>NIO：Selector</h1><p>Java中的IO多路复用主要靠的就是Selector，可以实现一个线程监听多个Channel。我们直接通过代码来看看Selector的使用步骤：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先创建一个ServerSocketChannel</span></span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">//服务器配置为非阻塞，这步是必须的，不然阻塞了就轮训不了</span></span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//获得服务器套接字</span></span><br><span class="line">ServerSocket serverSocket = serverSocketChannel.socket();</span><br><span class="line"><span class="comment">//进行服务的端口绑定</span></span><br><span class="line">serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"><span class="comment">//通过open()方法得到Selector</span></span><br><span class="line">Selector  selector = Selector.open();</span><br><span class="line"><span class="comment">//将ServerSocketChannel注册到selector，等待连接</span></span><br><span class="line"><span class="comment">//SelectionKey.OP_ACCEPT意味着只有当连接事件发生后，这个key才会被轮训上来</span></span><br><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过死循环轮训</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">//轮训该selector上的Channel</span></span><br><span class="line">    <span class="comment">//这个方法是阻塞的，非阻塞请使用selectNow()</span></span><br><span class="line">    selector.select();</span><br><span class="line">    <span class="comment">// 返回此selector的已选择键集。</span></span><br><span class="line">    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过迭代器遍历key集合</span></span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey selectionKey = iterator.next();</span><br><span class="line">        iterator.remove();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//说明是连接事件</span></span><br><span class="line">        <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// 返回为之创建此键的通道。</span></span><br><span class="line">            ServerSocketChannel server = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="comment">// 接受到此通道套接字的连接。</span></span><br><span class="line">            <span class="comment">// 此方法返回的套接字通道（如果有）将处于阻塞模式。</span></span><br><span class="line">            SocketChannel client = server.accept();</span><br><span class="line">            <span class="comment">// 配置为非阻塞</span></span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 注册到selector，等待读事件</span></span><br><span class="line">            client.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//说明是可读事件</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// 返回为之创建此键的通道。</span></span><br><span class="line">            SocketChannel client = (SocketChannel) selectionKey.channel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//读取数据，省略号：</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//说明是写事件</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isWritable()) &#123;</span><br><span class="line">            <span class="comment">// 返回为之创建此键的通道。</span></span><br><span class="line">            SocketChannel client = (SocketChannel) selectionKey.channel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//写入数据，省略号：</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>selector用在TCP服务端较多，因为要处理大量的TCP请求，总的概括一下，selector的使用流程如下：</p>
<ol>
<li>创建ServerSocketChannel，并配置为非阻塞。</li>
<li>创建selector并将之前创建的ServerSocketChannel注册到selector上。</li>
<li>循环轮训selector上的Channel，一次轮训后有事件发生，则获取selectionKeys集合。</li>
<li>遍历selectionKeys集合，根据key的事件不同采取不同的措施。</li>
<li>重复3，4。</li>
</ol>
<p>Selector就先介绍到这里，下一次见到Selector可能就是在Netty的源码解析文章中了～</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>总的来说，简单介绍了下NIO的三大组件，以及它们的工作方式。Buffer用来读写数据；Channel作为通道，是数据的来源或者目的地；Selector实现了一个线程管理多个Channel功能。相信看完这篇文章，大家对NIO就不会再那么陌生了，也对后续Netty的学习打下了一定的基础～</p>
]]></content>
      <categories>
        <category>IO</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>集合中的fail-fast机制</title>
    <url>/2020/02/17/%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84fail-fast%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>阿里巴巴Java开发手册中有这样一条规定：不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用<br>Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。</p>
<p>本文将从源码的角度去解释这条规定。</p>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先让我们违反一下规定，看看情况如何：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       ArrayList&lt;Integer&gt; arrayList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       arrayList.add(<span class="number">1</span>);</span><br><span class="line">       arrayList.add(<span class="number">2</span>);</span><br><span class="line">       arrayList.add(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer item : arrayList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item==<span class="number">1</span>) &#123;</span><br><span class="line">                arrayList.remove(item); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">运行结果：Exception in thread <span class="string">"main"</span> java.util.ConcurrentModificationException</span><br><span class="line">	        at java.base/java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="number">1042</span>)</span><br><span class="line">	        at java.base/java.util.ArrayList$Itr.next(ArrayList.java:<span class="number">996</span>)</span><br><span class="line">	        at Atomic.main(Atomic.java:<span class="number">19</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到在进行foreach循环的过程中，对元素进行了remove操作，直接抛出了ConcurrentModificationException异常。从这个异常中我们也可以看到，其实foreach循环底层也是靠的迭代器来实现的（ArrayList$Itr）。因此我们从集合中的迭代器入手，来看看这个异常是如何产生的。</p>
<h1 id="集合中的迭代器"><a href="#集合中的迭代器" class="headerlink" title="集合中的迭代器"></a>集合中的迭代器</h1><p>仍旧以ArrayList为例，看看ArrayList中的迭代器是怎样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>调用ArrayList的iterator()方法，返回一个Itr类，这是一个ArrayList的私有内部类。</p>
<h2 id="内部属性"><a href="#内部属性" class="headerlink" title="内部属性"></a>内部属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下一个将要访问元素的索引，初始化的时候是0，也就是第一个元素</span></span><br><span class="line"><span class="keyword">int</span> cursor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最近访问的元素索引，初始化的时候是-1       </span></span><br><span class="line"><span class="keyword">int</span> lastRet = -<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//这个就很关键了，预期的操作数，初始化的时候等于list对象的当前操作数</span></span><br><span class="line"><span class="keyword">int</span> expectedModCount = modCount;</span><br></pre></td></tr></table></figure>
<p>Itr类的属性不多，就三个。比较关键的是 expectedModCount这个属性，通过判断expectedModCount是否与当前modCount相同来判断是否可能出现并发操作。</p>
<h2 id="fail-fast机制"><a href="#fail-fast机制" class="headerlink" title="fail-fast机制"></a>fail-fast机制</h2><p>fail-fast的字面意思是“快速失败”。当我们在使用迭代器遍历元素的过程中，如果集合的结构被改变的话，就会抛出异常，防止继续遍历。这就是所谓的快速失败机制。</p>
<p>这张情况多发生于多线程环境下（单线程也有可能，比如上面这个例子），我们一起来看一下源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历下一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//fail-fast机制判断</span></span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">int</span> i = cursor;</span><br><span class="line">    <span class="comment">//没有下一个元素了</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="comment">//可能发生并发修改了，也抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    <span class="comment">//设置下一个元素索引</span></span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//返回当前遍历元素，设置lastRet为当前元素索引</span></span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    <span class="comment">//fail-fast机制判断</span></span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//修改expectedModCount为当前数组的modCount</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fail-fast机制的核心方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断当前modCount是否与预期操作数相同，如果不同说明可能有并发操作修改数组，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码不多，也挺好理解的。在之前的ArrayList源码解析中，可以看到每次对list进行操作都会对list内部的modCount进行自增。但是在迭代器内部的expectedModCount变量初始化后是对象私有的。如果调用list的方法，并不会修改expectedModCount的值，这就造成了expectedModCount与modCount不相等，此时迭代器就会认为，有并发操作修改list了，自然就抛出异常，终止遍历。只有当使用调用迭代器的remove方法时，才会使得expectedModCount与modCount同步。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>当Iterator这个迭代器被创建后，除了迭代器本身的方法(remove)可以改变集合的结构外，其他的因素如若改变了集合的结构，都被抛出ConcurrentModificationException异常，这也就是Java中的fail-fast机制。但是，我们不能依赖这个机制来解决并发问题。在多线程环境下，我们应该使用线程安全的集合，比如CopyOnWriteArrayList、ConcurrentHashMap等。</p>
]]></content>
      <categories>
        <category>规范</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>源码</tag>
        <tag>集合</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList源码解析</title>
    <url>/2020/02/16/ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>ArrayList也是一种老生常谈的集合。它的底层数据结构是数组，支持动态扩容。优点是查询速度快，时间效率高；缺点是空间效率不高。我自己在项目中ArrayList用的也挺多的，但是之前也没有看过底层实现，很多理解也只是在停留在表面。想要深入理解，还是得分析源码，从中学习，本文的目的也在于此。</p>
<p>PS：JDK版本12</p>
<a id="more"></a>
<h1 id="ArrayList的属性"><a href="#ArrayList的属性" class="headerlink" title="ArrayList的属性"></a>ArrayList的属性</h1><p>ArrayList的属性还是比较简单的，直接看注释就行了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组的默认长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空对象数组，初始化容量为0的时候使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空对象数组，使用无参构造方法使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//元素数组，就是底层存放元素的容器</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>ArrayList的构造函数有三个，不过总的来说就干了一件事，就是初始化一下数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有参构造方法，输入初始化容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//这里对元素数组进行初始化操作</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA; <span class="comment">//空数组&#123;&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无参构造方法，数组初始化为空数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; <span class="comment">//空数组&#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造方法，输入一个集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h1><p>添加方法一共有四个，这边介绍两种比较核心的：</p>
<ol>
<li>boolean add(E e)，默认在末尾添加元素。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们调用的是这个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对操作数加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    add(e, elementData, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际调用这个方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e, Object[] elementData, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果已经到了容量上限了，则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    <span class="comment">//添加元素，size+1</span></span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>void add(int index, E element)，在特定位置插入元素。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断索引的合理性，如不合理则抛出异常</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((s = size) == (elementData = <span class="keyword">this</span>.elementData).length)</span><br><span class="line">        elementData = grow();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里需要对数组进行整体的位移，空出我们要插入的那个位置，这一步开销比较大</span></span><br><span class="line">    System.arraycopy(elementData, index,</span><br><span class="line">                     elementData, index + <span class="number">1</span>,</span><br><span class="line">                     s - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><p>ArrayList很重要的一个特性是能够随着元素的增加动态的进行扩容，来看一下它的扩容方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="keyword">int</span> minCapacity) &#123;</span><br><span class="line">    <span class="comment">//拷贝，扩容，构建一个新的数组</span></span><br><span class="line">    <span class="keyword">return</span> elementData = Arrays.copyOf(elementData,</span><br><span class="line">                                       newCapacity(minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终调用这个方法，返回一个新的容量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">//当前数组长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//首先将数组长度变为1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">////如果扩容后的长度小于当前数据量，那么就将当前数据量的长度作为本次扩容的长度</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//这里判断数组是否为空来进行真正的初始化，初始容量为默认容量和minCapacity中的较大值</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果如果扩容后的长度大于当前数据量，根据newCapacity的大小返回新容量</span></span><br><span class="line">    <span class="keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="number">0</span>)</span><br><span class="line">        ? newCapacity</span><br><span class="line">        : hugeCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">        ? Integer.MAX_VALUE</span><br><span class="line">        : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h1><p>删除元素的方法常用的是两个，一个是根据索引删除，一个是根据元素删除：</p>
<ol>
<li>E remove(int index)，根据索引删除元素并返回被删除的元素。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//判断索引是否合理，不合理则抛出异常</span></span><br><span class="line">     Objects.checkIndex(index, size);</span><br><span class="line">     <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line"></span><br><span class="line">     E oldValue = (E) es[index];</span><br><span class="line">     <span class="comment">//最终调用的是这个方法</span></span><br><span class="line">     fastRemove(es, index);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> oldValue;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(Object[] es, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//操作数+1</span></span><br><span class="line">     modCount++;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> newSize;</span><br><span class="line">     <span class="comment">//如果不是末尾的元素，则需要对数组进行位移填补数组间的空隙</span></span><br><span class="line">     <span class="keyword">if</span> ((newSize = size - <span class="number">1</span>) &gt; i)</span><br><span class="line">         System.arraycopy(es, i + <span class="number">1</span>, es, i, newSize - i);</span><br><span class="line">     <span class="comment">//删除多余的元素，等待垃圾回收</span></span><br><span class="line">     es[size = newSize] = <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>boolean remove(Object o)，根据元素来删除并返回操作成功与否。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    found: &#123;</span><br><span class="line">        <span class="comment">//这里就可以看到，ArrayList是可以存放null的</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (es[i] == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span> found;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(es[i]))</span><br><span class="line">                    <span class="keyword">break</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到元素的索引后进行删除操作</span></span><br><span class="line">    fastRemove(es, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="查询元素"><a href="#查询元素" class="headerlink" title="查询元素"></a>查询元素</h1><p>查询元素就相当简单了，根据索引找就OK了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断索引是否合理</span></span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据索引返回对应位置上的元素</span></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>ArrayList的源码相对而言比较简单，其本质是数组，所以它在数据的查询方面会很快，而在插入删除这些方面，性能下降很多，因为需要移动很多数据才能达到应有的效果。</p>
]]></content>
      <categories>
        <category>集合</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>源码</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码解析</title>
    <url>/2020/02/15/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>哈希表是一种非常重要的数据结构，应用场景及其丰富。HashMap是Java中的哈希表实现，采用分离链表法解决hash冲突，其底层数据结构为数组+链表/红黑树（JDK1.8后）。其实关于网上关于HashMap的文章确实不少，不过大多感觉有点缺斤少两，有些疑惑的地方也没有解答，就我自己而言可能看了很多篇还是很模糊。所以想了想还是自己写一篇，争取能写的全面点，再加上一些自己的理解，希望能降低下大家的学习成本。</p>
<p>PS：JDK版本12</p>
<a id="more"></a>
<h1 id="HashMap的总体结构"><a href="#HashMap的总体结构" class="headerlink" title="HashMap的总体结构"></a>HashMap的总体结构</h1><p>我们先从总体来看，HashMap具体结构是怎么样的：</p>
<p><img src="https://i.loli.net/2020/03/03/R4NBa9wtKOmpDzU.jpg" alt="hashmap.jpg"></p>
<p>上面这张示意图还是比较直观的描述出了HashMap的结构，其中的结点有可能是链表或者是红黑树结点。在插入或者查询的过程中，可以通过头节点来判断是链表还是红黑树。JDK7中插入使用的是头插法，即每个结点插入在当前链表的表头。而JDK8中使用的是尾插法，结点都是添加在链表后边。</p>
<h1 id="HashMap的属性"><a href="#HashMap的属性" class="headerlink" title="HashMap的属性"></a>HashMap的属性</h1><p>我们来看看HashMap内部有哪些重要的属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16  默认初始化容量16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;        <span class="comment">//HashMap的最大容量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;     <span class="comment">//默认的负载因子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//链表转红黑树的阈值，即当链表的长度大于等于这个值的时候，将链表转换为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树转链表的阈值，当结点个数小于等于这个值时，将红黑树转换为链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果数组的长度小于这个数，则当链表的长度大于等于8时，优先扩展数组，而不是树化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个就是HashMap底层的Node数组了</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Node数组长度（K-V对的数量）</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作数，记录当前这个HashMap被操作了多少次，于fail-fast机制有关</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容的阈值</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>
<p>结点元素有两种，分别是链表结点和红黑树结点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表结点</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;    </span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">   省略号……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树结点，继承LinkedHashMap.Entry，后者又继承上面那个链表结点，所以是孙子辈</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    省略号……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结点属性还是蛮简单的，就是key，value，hash和指向其他结点的引用。</p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>实例化HashMap的时候最终都会调用这个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一个参数是初始容量，默认16，第二个参数是负载因子，默认0.75f</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="comment">//到此对参数的合理性判断完成</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置负载因子和初始扩容阈值                                       </span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="comment">//这边是获取第一次数组大小，HashMap的数组长度均为2的幂次方，至于为啥后面会提到</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取大于输入参数且最近的2的整数次幂</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到在实例化的时候，其实只是简单的设置了参数，而真正的初始化是在第一次put的时候进行的，这个我们后面会看到。</p>
<h1 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h1><p>在真正解析put方法之前，我们先来看看HashMap中的hash()，因为我们需要根据哈希值来定位元素在数组中的索引。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里用的是key的hash值与其自身高16为异或来减少hash冲突</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来看看put的过程分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们用的是这个，实际调用的是putVal</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//会计算一下key的hash值</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第四个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一次put的时候会触发resize()</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;   <span class="comment">//扩容方法后续会讲到</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据hash值找到数组的具体下标，注意这里用的是hash值&amp;（数组长度-1），这也是为什么数组长度必须是2的整数次幂    </span></span><br><span class="line">    <span class="comment">//如果该位置没有值，则初始化一下Node并放在这里就行了</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果已经有数据了    </span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先，判断该位置的第一个结点和我们要插入的数据，key 是不是"相等"，如果是，取出这个节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果该节点是红黑树结点，则调用红黑树的插值方法    </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果该结点是链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//开始遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//如果已经遍历到链表末尾了，则新建一个结点赋值给e</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//如果链表长度大于等于8，则将链表转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果在遍历的过程中找到了key“相等”的结点</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//e不为null说明有重复的key，需要对旧值进行覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//增加操作数</span></span><br><span class="line">    ++modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果由于新插入这个值导致size已经超过了阈值，需要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和JDK7中略有不同，JDK7中是先扩容再插入，JDK8是先插入再扩容。个人觉得可能是因为：在过去的版本中，由于使用的是头插法，插入的成本较低，可以先遍历一遍判断是否要新建结点；而后来插入使用尾插法，遍历一遍然后判断再插入相当于两次遍历链表，性能不佳。</p>
<h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><p>resize()方法用于初始化数组或数组扩容，每次扩容后，容量为原来的2倍，并进行数据迁移。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length; <span class="comment">//旧数组长度</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;                            <span class="comment">//旧扩容阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">//判断旧的数组长度，如果大于0说明不是初始化而是正常的扩容</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将数组长度和阈值均*2</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这一步是在初始化的时候设置数组的初始化长度</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用新的数组大小初始化数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是初始化，那么oldTab就是null，就直接返回newTab</span></span><br><span class="line">    <span class="comment">//下一步就是开始进行数据迁移了</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这个位置上没有元素就跳过</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果该数组位置上只有单个元素，计算新的位置，直接迁移这个元素即可</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果是红黑树结点，则使用其他方式数据迁移，这里就不展开了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//这里开始处理链表，此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//后面的逻辑就比较简单了</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//每个结点计算hash值来判断是在哪条链表上</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//第一条链表放到相应的位置</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//第二条链表的新的位置是j+oldCap，这里应该还挺好理解的</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h1><p>相比之前，get方法相对来说还是比较简单的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断第一个结点是不是就是需要的</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断是否为红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历链表</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>其实相比一些线程安全的集合，HashMap的源码也不是很难。本文主要讲了HashMap的总体结构和常用的方法，对于其中的树化方法等并没有详细展开讲，后续有空的话，大概会写一些这方面的文章。这次先到这里吧，祝大家看的愉快～</p>
]]></content>
      <categories>
        <category>集合</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>源码</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>浮点数与BigDecimal</title>
    <url>/2020/02/13/%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8EBigDecimal/</url>
    <content><![CDATA[<p>在之前写软件的时候出现过这样一种情况，软件界面在显示位移的时候，经常会出现类似于1.9999999964这样子的小数。当时可真是百思不得其解呀，到底问题出在哪？</p>
<p>后来才知道，我在计算位移的时候使用的浮点数，而浮点数是存在精度损失的。后来我把浮点数换成了BigDecimal，问题就解决了。这篇文章也算是记录下自己所踩的坑。</p>
<a id="more"></a>
<h1 id="浮点数的存储"><a href="#浮点数的存储" class="headerlink" title="浮点数的存储"></a>浮点数的存储</h1><p>Java中的浮点数主要有float和double两类，众所周知，float占据4字节，double占据8字节，我们来看看这两种类型是怎么存储数据的。</p>
<h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><table>
<thead>
<tr>
<th align="center">符号位：1bit</th>
<th align="center">指数位：8bit</th>
<th align="center">尾数位：23bit</th>
</tr>
</thead>
</table>
<h2 id="double"><a href="#double" class="headerlink" title="double"></a>double</h2><table>
<thead>
<tr>
<th align="center">符号位：1bit</th>
<th align="center">指数位：11bit</th>
<th align="center">尾数位：52bit</th>
</tr>
</thead>
</table>
<h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p>我们以89.625f作为例子来说明计算机中浮点数是怎么储存的。在对十进制浮点数进行转换的时候，需要将整数部分和小数部分分开处理。</p>
<ul>
<li><p>整数部分：十进制89转化成二进制为10110012。</p>
</li>
<li><p>小数部分：十进制小数转二进制数的步骤是“乘以2取整，顺序排列”。所以0.625转化为二进制小数为0.101，具体步骤如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">乘数</th>
<th align="center">*</th>
<th align="center">乘数</th>
<th align="center">=</th>
<th align="center">积</th>
<th align="center">整数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0.625</td>
<td align="center">*</td>
<td align="center">2</td>
<td align="center">=</td>
<td align="center">1.25</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">0.25（此处是1.25的小数部分）</td>
<td align="center">*</td>
<td align="center">2</td>
<td align="center">=</td>
<td align="center">0.5</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0.5</td>
<td align="center">*</td>
<td align="center">2</td>
<td align="center">=</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<ul>
<li>转换结果：89.625（10）=1011001.101（2）</li>
<li>存储方式：</li>
</ul>
<ol>
<li>符号位：因为是正数，所以为0。</li>
<li>指数为：因为采用科学计数法，所以小数点左边只能留一位且必须为1，所以为1.1011001101*2^6，规定指数位的底为2且幂加127（double类型加1023），所以指数位为133(127+6)，转换为二进制为10000101。</li>
<li>尾数位： 规定尾数位去掉规范化前边的整数位的1，只保存小数，所以尾数位为011001101</li>
</ol>
<p>所以我们最终得到的浮点数为：</p>
<table>
<thead>
<tr>
<th align="center">符号位：1bit</th>
<th align="center">指数位：8bit</th>
<th align="center">尾数位：23bit</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">10000101</td>
<td align="center">01100110100000000000000</td>
</tr>
</tbody></table>
<h1 id="浮点数的缺陷"><a href="#浮点数的缺陷" class="headerlink" title="浮点数的缺陷"></a>浮点数的缺陷</h1><p>有了前面的铺垫，我们大概可能猜到浮点数的问题出在哪里了。主要问题就出在小数部分转二进制这一步。</p>
<p>我们以0.9为例：</p>
<table>
<thead>
<tr>
<th align="center">乘数</th>
<th align="center">*</th>
<th align="center">乘数</th>
<th align="center">=</th>
<th align="center">积</th>
<th align="center">整数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0.9</td>
<td align="center">*</td>
<td align="center">2</td>
<td align="center">=</td>
<td align="center">1.8</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">0.8</td>
<td align="center">*</td>
<td align="center">2</td>
<td align="center">=</td>
<td align="center">1.6</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">0.6</td>
<td align="center">*</td>
<td align="center">2</td>
<td align="center">=</td>
<td align="center">1.2</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">0.2</td>
<td align="center">*</td>
<td align="center">2</td>
<td align="center">=</td>
<td align="center">0.4</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0.4</td>
<td align="center">*</td>
<td align="center">2</td>
<td align="center">=</td>
<td align="center">0.8</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0.8</td>
<td align="center">*</td>
<td align="center">2</td>
<td align="center">=</td>
<td align="center">1.6</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">……</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>上面的计算过程循环了，也就是说*2永远不可能消灭小数部分，这样算法将无限下去。很显然，小数的二进制表示有时是不可能精确的。超出的部分必须对其截断，造成了部分精度的丢失。</p>
<p>我们来直观的感受下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">0.9f</span>-<span class="number">0.8f</span>;    <span class="comment">//0.9-0.8=0.1？</span></span><br><span class="line">    System.out.println(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：<span class="number">0.099999964</span></span><br></pre></td></tr></table></figure>
<h1 id="BigDecimal简介"><a href="#BigDecimal简介" class="headerlink" title="BigDecimal简介"></a>BigDecimal简介</h1><p>Java在java.math包中提供的API类BigDecimal，用来对数字进行<strong>精确</strong>的运算，这意味着BigDecimal不会像浮点数一样丢失精度。我也是从《Effective Java》一书中学习到的，在进行工程计算时，误差允许的情况下，推荐使用浮点数，因为其计算效率更高；但是如果要求数字十分精确，不允许有误差的时候，比如货币，推荐使用BigDecimal。</p>
<h2 id="常用的构造函数"><a href="#常用的构造函数" class="headerlink" title="常用的构造函数"></a>常用的构造函数</h2><ol>
<li><p>BigDecimal(int)：创建一个具有参数所指定整数值的对象</p>
</li>
<li><p>BigDecimal(double)：创建一个具有参数所指定双精度值的对象</p>
</li>
<li><p>BigDecimal(long)：创建一个具有参数所指定长整数值的对象</p>
</li>
<li><p>BigDecimal(String)：创建一个具有参数所指定以字符串表示的数值的对象  （建议使用！）</p>
</li>
</ol>
<p>通常情况下而言，推荐使用String构造方法，因为其完全是可预知的：写入 newBigDecimal(“0.1”) 将创建一个 BigDecimal，它正好等于预期的0.1。</p>
<p>请看下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    BigDecimal bigDecimal1=<span class="keyword">new</span> BigDecimal(<span class="number">0.1</span>);</span><br><span class="line">    BigDecimal bigDecimal2=<span class="keyword">new</span> BigDecimal(<span class="string">"0.1"</span>);</span><br><span class="line">    System.out.println(bigDecimal1);</span><br><span class="line">    System.out.println(bigDecimal2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:<span class="number">0.1000000000000000055511151231257827021181583404541015625</span></span><br><span class="line">        <span class="number">0.1</span></span><br></pre></td></tr></table></figure>

<h2 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h2><p>因为BigDecimal本身是一个对象，所以我们不能对其直接进行运算符操作，而需要调用对应的方法。</p>
<ul>
<li>加法：add(BigDecimal augend)</li>
<li>减法：subtract(BigDecimal subtrahend)</li>
<li>乘法：multiply(BigDecimal multiplicand)</li>
<li>除法：divide(BigDecimal divisor, int scale, int roundingMode)</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>关于BigDecimal的用法其实还有很多，这边就不具体展开了，感兴趣的朋友可以深入了解下～。其实对于浮点数和BigDecimal这两者而言，我们具体选择哪一个，更多的还是看我们的使用场景，切忌为了用而用，比如我非要用BigDecimal去解方程这样子，那就有点南辕北辙了。在使用一个技术前，我们还是需要思考一下，为什么要用。</p>
]]></content>
      <categories>
        <category>规范</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么阿里巴巴手册中禁用默认实现的线程池</title>
    <url>/2020/02/12/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%89%8B%E5%86%8C%E4%B8%AD%E7%A6%81%E7%94%A8%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p>在阿里巴巴Java开发手册中有一条规则：【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p>
<p>如何去理解这句话？</p>
<a id="more"></a>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>线程池的使用应该是非常常见的，包括我自己在项目中也有用到。Java中为我们提供了四种默认实现的线程池，分别是：</p>
<ol>
<li>newFixedThreadPool(int Threads):创建固定数目的线程池。</li>
<li>newSingleThreadPoolExecutor():创建一个单线程的线程池。</li>
<li>newCacheThreadPool():创建一个可缓存的线程池，调用execute将重用以前构成的线程。</li>
<li>newScheduledThreadPool(int corePoolSize)：创建一个支持定时及周期性的任务执行的线程池</li>
</ol>
<p>后来在阅读阿里巴巴Java开发手册的时候，其中明确指出了，线程池不允许使用Executors去创建。那么用默认实现的线程池会有什么隐患？这可能需要从线程池的参数和运行机制说起……</p>
<h1 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h1><p>不论是使用默认的线程池还是自定义的线程池，最后都会调用这样子的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数的参数说明：</p>
<table>
<thead>
<tr>
<th align="left">参数名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">corePoolSize</td>
<td align="left">线程池核心线程数量</td>
</tr>
<tr>
<td align="left">maximumPoolSize</td>
<td align="left">线程池最大线程数量</td>
</tr>
<tr>
<td align="left">keepAliveTime</td>
<td align="left">空闲线程存活时间</td>
</tr>
<tr>
<td align="left">unit</td>
<td align="left">时间单位</td>
</tr>
<tr>
<td align="left">workQueue</td>
<td align="left">线程池所使用的缓冲队列</td>
</tr>
<tr>
<td align="left">threadFactory</td>
<td align="left">线程池创建线程使用的工厂</td>
</tr>
<tr>
<td align="left">handler</td>
<td align="left">线程池对拒绝任务的处理策略</td>
</tr>
</tbody></table>
<h1 id="线程池的运行机制"><a href="#线程池的运行机制" class="headerlink" title="线程池的运行机制"></a>线程池的运行机制</h1><p>线程池的运行机制如下图所示：</p>
<p><img src="https://i.loli.net/2020/03/02/Z5DvrTj2gX7Vye3.jpg" alt="threadpool.jpg"></p>
<h1 id="Executors实现的默认线程池及其隐患"><a href="#Executors实现的默认线程池及其隐患" class="headerlink" title="Executors实现的默认线程池及其隐患"></a>Executors实现的默认线程池及其隐患</h1><h2 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h2><p>固定线程数的线程池通过Executors.newFixedThreadPool(int nThreads)来创建，我们看看它的详细参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其核心线程数和最大线程数是相等的，而它所使用的阻塞队列是无界的（准确的说最大值为Integer.MAX_VALUE）。当我们提交任务到达线程数上限的时候，如果线程执行任务的速度远小于任务的提交速度，那么任务就会在阻塞队列中堆积，有OOM的隐患。</p>
<h2 id="SingleThreadPoolExecutor"><a href="#SingleThreadPoolExecutor" class="headerlink" title="SingleThreadPoolExecutor"></a>SingleThreadPoolExecutor</h2><p>单线程的线程通过Executors.SingleThreadPoolExecutor()来创建，我们看看它的详细参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其核心线程数和最大线程数恒为1，而它所使用的阻塞队列也无界的。这就出现了与FixedThreadPool相同的问题，有OOM的隐患。</p>
<h2 id="CacheThreadPool"><a href="#CacheThreadPool" class="headerlink" title="CacheThreadPool"></a>CacheThreadPool</h2><p>缓存线程池通过Executors.newCacheThreadPool()来创建，我们看看它的详细参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这线程池比较特殊，当一个任务提交时，corePoolSize为0不创建核心线程，SynchronousQueue是一个不存储元素的队列，可以理解为队里永远是满的，因此最终会创建非核心线程来执行任务。对于非核心线程空闲60s时将被回收。因为Integer.MAX_VALUE非常大，可以认为在任务提交过快的时候是可以无限创建线程的，在资源有限的情况下容易引起OOM异常。</p>
<h2 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h2><p>延时线程池又是一类特殊的线程池，可以通过Executors.newScheduledThreadPool(int corePoolSize)来创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ScheduledThreadPoolExecutor是一个继承自ThreadPoolExecutor的类，最终调用的还是ThreadPoolExecutor的构造方法。这一类线程池出现隐患的地方在于它的队列DelayedWorkQueue，这是一个ScheduledThreadPoolExecutor的内部类。这个队列的初始量为16，当队列满了之后会自动进行扩容，容量上限为Integer.MAX_VALUE，因此如果线程执行任务的速度远小于任务的提交速度，那么任务就会在阻塞队列中堆积，有OOM的隐患。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>大概说了说每种线程池出现隐患的原因，在实际使用的时候，我们可以采用自定义ThreadPoolExecutor的方式来使用线程池。话说回来，规范之所以是规范，一定是有原因，我们除了遵守规范以外，最好还是要去理解它背后深层次的原因。</p>
]]></content>
      <categories>
        <category>规范</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>原创</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal解析</title>
    <url>/2020/02/11/ThreadLocal%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>在之前的几篇文章中，更多的讲的是线程之间的并发操作，多线程在读写共享变量时可能需要进行一些同步操作或者是将变量用volatile修饰等等。如果说每个线程都需要自己的独立实例，且该实例需要在多个方法中被使用（相同线程数据共享），又该如何去实现呢？在方法参数上定义这个共享的变量吗？显然这样子耦合太严重了，牵一发而动全身；那么使用一个全局的集合来共享数据？这又涉及到了多个线程之间的同步问题，只是为了能让线程间隔离数据而使用同步开销太大。</p>
<p>ThreadLocal就是适用于这样的场景。本文从ThreadLocal的简单使用开始入手，通过源码来阐述其使用原理以及一些隐患。</p>
<a id="more"></a>

<h1 id="ThreadLocal简介"><a href="#ThreadLocal简介" class="headerlink" title="ThreadLocal简介"></a>ThreadLocal简介</h1><p>ThreadLocal是JDK包提供的一种工具，我们可以从名字这里看到，它能够提供线程的本地变量，每次线程读写变量时，都是读写的本地变量，这就实现了一个线程之间变量的隔离。</p>
<h1 id="ThreadLocal的简单使用"><a href="#ThreadLocal的简单使用" class="headerlink" title="ThreadLocal的简单使用"></a>ThreadLocal的简单使用</h1><p>这边给出一段代码，来帮助我们直观的了解ThreadLocal是如何使用的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TL</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal=<span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//打印线程名称以及该线程对应的本地变量</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">": "</span>+threadLocal.get()); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            threadLocal.set(<span class="string">"这是副线程"</span>); <span class="comment">//副线程设置ThreadLocal</span></span><br><span class="line">            print();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        threadLocal.set(<span class="string">"这是main线程"</span>);  <span class="comment">//主线程设置ThreadLoacl</span></span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main: 这是main线程</span><br><span class="line">Thread-0: 这是副线程</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，一共两个线程，主线程和副线程。在每个线程内部设置了本地变量的值，然后调用print方法打印当前线程名和本地变量的值，可以发现即使是一个ThreadLocal变量，不同的线程从中获取的值是不同的。</p>
<h1 id="ThreadLocal的实现原理"><a href="#ThreadLocal的实现原理" class="headerlink" title="ThreadLocal的实现原理"></a>ThreadLocal的实现原理</h1><p>在分析ThreadLocal的源码之前，或许从宏观上了解一下本地变量是如何储存的比较好，这样到时候去看源码的时候就不会一脸懵逼（我当时就是这样的）。我把ThreadLocal的储存原理抽象一下，请看下面这张图：</p>
<p><img src="https://i.loli.net/2020/03/02/eO2NctRIHMrnwFm.jpg" alt="ThreadLocal.jpg"></p>
<p>我们把ThreadLocal当作一张一卡通，可以开启所有的储物柜对应id的格子。比如图中的ThreadLocal一卡通可以打开所有储物柜的1号格子。但是不同的储物柜里，放着不同的东西，比如：饮料、食物等。我们即使使用相同的卡去开格子，不同的储物柜得到的东西也是不同的。我们得到的一定是上次往这个储物柜里放的东西。</p>
<p>再结合上一节里的代码，我们可以思考一段时间再往下看。</p>
<p>不同的线程设置本地变量，就像我们拿着卡在不同的储物柜存放东西；下次对应线程取出本地变量时，就像拿着卡去对应的储物柜获取东西。这样理解起来，或许会更方便一些，线程与ThreadLocal存在着这样一种对应关系。那么问题来了，线程是怎么储存本地变量的？或者说，线程是怎么提供类似于储物柜这样子的功能的。我们来看看Thread(注意不是ThreadLocal)的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>我们可以看到Thread中有这样一个属性，叫做ThreadLocalMap，初始化的时候是null，它是属于ThreadLocal内部的一个类，就是这个Map实现了类似于储物箱的功能。现在翻开ThreadLocal的源码，看看这个内部类是怎么回事（源码有点长，我做了简略）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//Entry为ThreadLocalMap静态内部类，对ThreadLocal的弱引用</span></span><br><span class="line">       <span class="comment">//同时让ThreadLocal和储值形成key-value的关系</span></span><br><span class="line">       <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">           </span><br><span class="line">           Object value;</span><br><span class="line"></span><br><span class="line">           Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">               <span class="keyword">super</span>(k);</span><br><span class="line">               value = v;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">       省略号……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这段代码我们不难发现，ThreadLocalMap很像HashMap（hash冲突的处理不同），内部是一个Entry数组，用于存放ThreadLocal-Value的。一切的存放/读取操作都是通过这个Entry数组来实现的。<strong>值得注意的是</strong>，这个Entry类型对ThreadLocal也就是Key是一个弱引用，这点下文会提到。</p>
<p>到了这里，应当可以知道，每个线程是如何存放本地变量的了：每个线程Thread持有一个ThreadLocalMap类型的实例threadLocals，在存放的时候，以ThreadLocal为Key来存取Value到线程私有的ThreadLocalMap中去；获取的时候也是以ThreadLocal为Key到自己线程持有的ThreadLocalMap中去拿。这也解释了为什么相同的ThreadLocal会取得不同的实例对象，因为存放容器的对象是不同的。大家可以再仔细思考下～</p>
<p>我们再来看看ThreadLocal比较重要的两个方法，即set（），get（）的底层实现。</p>
<p>首先是set（）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">       Thread t = Thread.currentThread(); <span class="comment">//获取当前线程</span></span><br><span class="line">       ThreadLocalMap map = getMap(t);    <span class="comment">//获取当前线程所持有的ThreadLocalMap</span></span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;                 <span class="comment">//如果ThreadLocalMap不为空，存入自己和value</span></span><br><span class="line">           map.set(<span class="keyword">this</span>, value);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           createMap(t, value);           <span class="comment">//否则给当前线程新建一个ThreadLocalMap，并存入value</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>set方法比较简单，可以直接看注释，接下来是get（）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread(); <span class="comment">//获取当前线程</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);    <span class="comment">//获取当前线程所持有的ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;                 <span class="comment">//如果map不为空则根据自己来获取Entry</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;               <span class="comment">//如果Entry不为空则根返回Entry中的value</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();        <span class="comment">//如果没有map或者找不到对应的Entry 调用setInitialValue()并返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();         <span class="comment">//就是null</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;               <span class="comment">//map存在则插入自己和null，也就是说Entry可以允许值为null</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value);         <span class="comment">//否则创建map并插入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> TerminatingThreadLocal) &#123;</span><br><span class="line">        TerminatingThreadLocal.register((TerminatingThreadLocal&lt;?&gt;) <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;      <span class="comment">//返回null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get（）方法也不难。。注释写的应该挺清楚了。当然还有个比较重要的remove方法，记得使用完ThreadLocal后调用（划重点！！）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">         <span class="keyword">if</span> (m != <span class="keyword">null</span>) &#123;</span><br><span class="line">             m.remove(<span class="keyword">this</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>remove方法主要就是在使用完ThreadLocal后，释放一些资源，以免造成内存泄漏，代码也不难～</p>
<h1 id="内存泄漏的隐患"><a href="#内存泄漏的隐患" class="headerlink" title="内存泄漏的隐患"></a>内存泄漏的隐患</h1><p>ThreadLocal使用起来虽然很方便，但是用的不恰当的也会有风险，比如内存泄漏。所谓内存泄漏，是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。更直白一点，这个对象我们以后我们都用不到了，但是他还没有被垃圾回收掉。</p>
<p>之前在说ThreadLocalMap中的Entry时，注意到Entry对ThreadLocal是弱引用。如果看过《深入理解Java虚拟机》的读者可能会在知道，如果一个对象只具有弱引用，那么这个对象就会被垃圾回收器GC掉(被弱引用所引用的对象只能生存到下一次GC之前，当发生GC时候，无论当前内存是否足够，弱引用所引用的对象都会被回收掉)。</p>
<p>我们结合下面这张图来看看ThreadLocal内存泄漏是怎么产生的：</p>
<p><img src="https://i.loli.net/2020/03/02/4WNC2IznovdTguj.jpg" alt="tl2.jpg"></p>
<p>根据这张引用关系图我们可以看到，当虚拟机栈中的ThreadLocal引用失效后，由于Entry对ThreadLocal是弱引用，所以在垃圾回收的时候，可以回收掉ThreadLocal，此时Map中会存在Key为null但是Value不为null的Entry。如果线程一直不结束（比如使用了线程池），此时会存在一条强引用链：虚拟机栈中的Thread引用-&gt;Thread对象-&gt;ThreadLocalMap-&gt;Entry-&gt;Object对象。尽管这个Object对象我们不再使用，但是只要线程还在或者不采取其他措施，这个对象是无法回收的，这也就造成了内存泄漏。</p>
<p>当然ThreadLocal并非没有预防措施，其思路在于把Key为null的Entry中，指向Object的强引用给掐掉，就可以了。事实上，在ThreadLocalMap中，每次新增、移除、获取的时候都会去擦除Key为Null的Value，但是这些措施并不能保证一定不会内存泄露,比如:使用了static修饰的ThreadLocal，延长了ThreadLocal的生命周期,可能会导致内存泄露；分配使用了ThreadLocal又不再调用get、set或者remove方法也会导致内存泄露等等。</p>
<p>所以为了避免内存的泄露,每次使用完 ThreadLocal 的时候都需要调用 remove() 方法来擦除数据。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>总的来说ThreadLocal以其巧妙的设计，实现了多线程环境下变量隔离的功能，在使用的时候我们还是需要养成用完过后remove的好习惯～</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>原创</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的原子基本类型类</title>
    <url>/2020/02/09/Java%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB/</url>
    <content><![CDATA[<p>Java从JDK1.5开始提供了java.util.concurrent.atomic包，这个包中当原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。变量的类型有很多，所以Atomic包下一共提供了13个类。本文主要以AtomicInteger为例，以小见大，对它的源码进行剖析，来明白原子类的实现原理。<br>阅读本文前，最好对volatile和CAS有一定了解，这方面可以请看上一篇文章。</p>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>原子类顾名思义就是为了解决原子性操作问题的，我们借之前一个例子来讲解下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Atomic</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> num=<span class="number">0</span>; <span class="comment">//这是一个volatile修饰的共享变量，可以解决内存可见性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; <span class="comment">//新启一个线程</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">                    num++;   <span class="comment">//对num进行自增1操作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; <span class="comment">//新启另一个线程</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">                    num++;   <span class="comment">//对num进行自增1操作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start(); <span class="comment">//启动这两个线程</span></span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的结果，num几乎不会出现等于2000的情况。原因我在此就不赘述了，可以看之前的那片文章——<a href="http://www.mybulinbulin.cn/2020/02/29/%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E9%87%8D%E6%8E%92%E5%BA%8F/" target="_blank" rel="noopener">传送门</a></p>
<p>现在我们换成AtomicInteger试一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Atomic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger atomicInteger=<span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">                atomicInteger.getAndIncrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">                atomicInteger.getAndIncrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行这段代码大家可以看到,最终结果一定是正确的（不正确的话睡的时间长一点）。那么原子类是如何实现原子性的自增的呢？</p>
<h1 id="AtomicInteger中的属性"><a href="#AtomicInteger中的属性" class="headerlink" title="AtomicInteger中的属性"></a>AtomicInteger中的属性</h1><p>我们先来看看AtomicInteger里面有什么，直接贴上源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Unsafe类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象地址的偏移量</span></span><br><span class="line">private static final long VALUE = U.objectFieldOffset(AtomicInteger.class, "value");</span><br><span class="line"></span><br><span class="line"><span class="comment">//变量值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure>
<p>我们可以看到除了序列号意外，AtomicInteger中主要有三个属性，分别是：Unsafe类，long类型的对象地址的偏移量以及存储变量的value。</p>
<ul>
<li><p>变量值value：这个就是我们实际存储的int类型变量。注意这里用了volatile修饰，用于保证内存可见性。</p>
</li>
<li><p>Unsafe类：Unsafe是位于sun.misc包下的一个类，其主要功能是可用来直接访问系统内存资源并进行自主管理。Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”（所以才叫Unsafe），因此官方其实是不建议使用的。在这里，我们对变量进行原子操作所依靠的就是这个Unsafe类。</p>
</li>
<li><p>对象地址的偏移量：可以理解对象在内存中存储的位置，Unsafe类主要是根据这个值来找到我们的对象来进行更改。</p>
</li>
</ul>
<h1 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h1><p>我们来看看AtomicInteger中有哪些方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对当前值自增1，返回旧值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.getAndAddInt(<span class="keyword">this</span>, VALUE, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对当前值增加delta，返回旧值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.getAndAddInt(<span class="keyword">this</span>, VALUE, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以原子方式设置为newValue的值，并返回旧值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.getAndSetInt(<span class="keyword">this</span>, VALUE, newValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果输入的expectedValue等于预期值， 则以原子方式将该值设置为输入值，返回操作是否成功</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.compareAndSetInt(<span class="keyword">this</span>, VALUE, expectedValue, newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他的一些方法大同小异，可能是返回新值，也有可能是进行减操作等等。我们需要关注的是他最终调用的方法。这些方法里最终调用的都是Unsafe类的方法，比如getAndAddInt，getAndSetInt，compareAndSetInt等等。原子操作的奥秘其实都在这些方法里。</p>
<h1 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h1><p>我们以自增为例，看看调用U.getAndAddInt(this, VALUE, 1)发生了什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);   <span class="comment">//调用native方法获取预期值</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta)); <span class="comment">//使用CAS进行原子操作，操作成功后跳出循环</span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSetInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> compareAndSetInt(o, offset, expected, x);  <span class="comment">//底层使用的是CAS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们getAndAddInt方法使用死循环+CAS的方式来完成自增操作。具体流程如下：循环自旋不断尝试将一个比当前值大delta的新值赋给自己，如果失败则说明在执行”获取-设置”操作的时已经被其它线程修改过了，于是便再次进入循环下一次操作，直到成功为止。原子的将变量设定为新数据后，同时返回先前的旧数据。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>其实Atomic类的操作明没有那么复杂，最底层依赖的还是自旋CAS，有好处也有坏处。从好的方面来讲，AtomicInteger类可以保持其原子性。但是从坏的方面来看，Usafe因为直接操作的底层地址，肯定不是那么安全，而且CAS机制也伴随着大量的问题，比如ABA问题，自旋时间长开销大等等。总的来说，还是要根据使用场合来选择合适的同步方式或者类。</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>原创</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile和CAS</title>
    <url>/2020/02/08/volatile%E5%92%8CCAS/</url>
    <content><![CDATA[<p>在讲Java并发编程的时候，volatile关键字和CAS操作都扮演着重要的角色。本文之所以把这两个放在一起讲，是因为两者的有机结合能实现锁的功能。volatile能保证内存可见性和防止重排序，CAS能保证操作的原子性（其实也能保证可见性），两者结合几乎拓展出了整个Java的并发包，Java中Lock的底层实现AQS所依赖的也正是volatile和CAS。</p>
<p>话不多说，现在让我们一起揭开它们的神秘面纱吧～</p>
<a id="more"></a>

<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>volatile更像是轻量级的synchronized，它在多处理器开发中保证了共享变量的“内存可见性”。如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它没有加锁解锁的开销。</p>
<h2 id="volatile的定义"><a href="#volatile的定义" class="headerlink" title="volatile的定义"></a>volatile的定义</h2><p>Java语言规范第3版中对volatile的定义如下：Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁要更加方便。如果一个字段被声明成volatile，Java内存模型能确保所有线程看到这个变量的值是一致的，即保证了内存可见性。</p>
<h2 id="volatile的底层实现"><a href="#volatile的底层实现" class="headerlink" title="volatile的底层实现"></a>volatile的底层实现</h2><p>如果想知道volatile是如何保证内存可见性的，必然需要了解volatile的底层实现是什么。我们可以通过工具获取JIT编译器生成的汇编指令来查看对volatile进行写操作时，CPU会做些什么。</p>
<p>在对有volatile修饰的共享变量进行写操作时，会在对应的汇编指令前加上Lock前缀。结合Java内存模型，我们可以这么理解：</p>
<ol>
<li>将当前工作内存中的共享变量（all）写回到主内存中去。</li>
<li>步骤1会使得其他线程内的工作内存失效，后续读取共享变量必须从主内存中读取。</li>
</ol>
<p><img src="https://i.loli.net/2020/03/01/1rFnfOE3jT4Sx2h.jpg" alt="volatile.jpg"></p>
<p>当然，实际情况下，这涉及到操作系统的总线嗅探机制和MESI协议，这边就不再扩展了，有兴趣可以自行了解下～</p>
<h2 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h2><p>在学习《Java并发编程实战》这本书的时候，里面有句话令我印象十分的深刻。大致意思上说的是，比起内存可见性，volatile更重要的地方在于它的内存语义，使得它具有了一些锁的性质。</p>
<p>volatile的语义主要是读和写，具体如下：</p>
<ul>
<li>volatile写：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。</li>
<li>volatile读：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</li>
</ul>
<p>乍看之下好像就是保证内存可见性而已，没什么特殊的。其实这两句话我们得结合volatile另一个特性，也就是防止重排序来看。我们看下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Volatile</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFlag</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=n;       <span class="comment">//3 </span></span><br><span class="line">        <span class="keyword">boolean</span> res=flag;<span class="comment">//4</span></span><br><span class="line">        <span class="keyword">return</span> res;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(!isFlag())&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"over"</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        flag=<span class="keyword">true</span>;   <span class="comment">//1</span></span><br><span class="line">        n=<span class="number">1</span>;         <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子其实在之前的文章中也出现过类似的，其主要逻辑是主线程sleep 1s后修改标志位，另一个线程跳出循环，程序终止。如果只是保证内存可见性的话，如果<strong>1</strong>和<strong>2</strong>发生重排序了，那么死循环的线程时无法感知到<strong>flag</strong>的变化的。volatile的内存语义能够保证<strong>1</strong>不会重排序到<strong>2</strong>之后，<strong>4</strong>不会重排序到<strong>3</strong>之前。表现出来的情况就是，A线程在写volatile变量时，之前所有的共享变量的值都将立即变得对B可见，B在读volatile变量时，之后所有的共享变量都时新值。</p>
<p>我们会发现，其实volatile的写-读与锁的释放-获取有着相同的内存语义。但由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而锁的互斥执行可以确保整个临界区代码的执行具有原子性。所以从功能上说，锁更强大；在可伸缩性和执行性能上，volatile更有优势。</p>
<h2 id="volatile内存语义的实现原理"><a href="#volatile内存语义的实现原理" class="headerlink" title="volatile内存语义的实现原理"></a>volatile内存语义的实现原理</h2><p>在之前的文章中有提到过，编译器或者处理器为了提高运行效率会对指令进行重排序。为了实现volatile内存语义，编译器在声称字节码时，会在指令序列中插入内存屏障来紧致特定类型对处理器重排序。简单来说有下面四种：</p>
<ol>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障。</li>
</ol>
<p>可能看图来说会比较直观一点，请看下图</p>
<p><img src="https://i.loli.net/2020/03/02/QJBxqugDAsobh1e.jpg" alt="storestore.jpg"></p>
<p>这样子可能会好理解吧。正因为禁止了部分的重排序，加上内存可见性的保证，所以保证了volatile类似于锁的内存语义。</p>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>CAS指的是Compare And Swap（在Java中调用的函数应该为CompareAndSet），顾名思义是比较并替换的意思。CAS实际上是乐观锁的一种实现，不需要对资源加锁，当我们需要更改变量时，需要一个旧的预期值A,主内存的值是B，要修改的值C，当且仅当A==B的时候，A的值才会被修改成C，而且是一个非阻塞性的原子操作。一般而言，Java中大部分都是通过循环和CAS配合来实现修改变量的。</p>
<h2 id="CAS的实现原理"><a href="#CAS的实现原理" class="headerlink" title="CAS的实现原理"></a>CAS的实现原理</h2><p>我们可以追踪源码来看看CAS底层是如何实现的，以AtmoicInteger为例，其底层最终调用的方法为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSetInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以看到这是一个native方法，也就是说Java中的CAS底层是通过JNI去调用C代码操作OS来获取的一个原子操作，我们可以去openJDK查看这个指令的源码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Adding a lock prefix to an instruction on MP machine</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) <span class="meta-string">"cmp $0, "</span> #mp <span class="meta-string">"; je 1f; lock; 1: "</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> jint     <span class="title">Atomic::cmpxchg</span>    <span class="params">(jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">"cmpxchgl %1,(%3)"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"=a"</span> (exchange_value)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"r"</span> (exchange_value), <span class="string">"a"</span> (compare_value), <span class="string">"r"</span> (dest), <span class="string">"r"</span> (mp)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，最终会调用底层的一个CMPXCHG指令。程序会根据当前处理器的类型来决定是否为CMPXCHG指令添加LOCK前缀。如果程序是在多处理器上运行，就为CMPXCHG指令加上LOCK前缀（LOCK CMPXCHG）。反之，如果程序是在单处理器上运行，就省略LOCK前缀。这个LOCK前缀上文讲过了，volatile也是靠他实现内存可见性的，所以文章开头提到的其实CAS也能保证内存可见性，原因在此。</p>
<h2 id="CAS的三大问题"><a href="#CAS的三大问题" class="headerlink" title="CAS的三大问题"></a>CAS的三大问题</h2><p>CAS虽然很高效地解决了原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大，以及只能保证一个共享变量的原子操作。</p>
<ul>
<li><p>ABA问题：当CPU1从缓存里面读到了数值A，另一个CPU2这时候也从缓存里面读到了A，然后将他主内存里面的值先修改成B，再将他修改成A，释放缓存锁，此时CPU1获取到缓存锁，去读主内存里面的值，发现还是A，判断相等修改新值，这在CPU1的线程里面看起来是没有任何改变，但实际上主内存里面这块地址的值已经有了一个A-&gt;B-&gt;A的改变，自从jdk1.5之后，加入了AtomicStampedReference类来防止这个问题，通过将引用和版本号作为一个tuple来防止ABA问题，那么修改结果就会变成1A-&gt;1B-&gt;2A，就能看到内存里面这个值的改变。</p>
</li>
<li><p>循环时间长开销大：CAS配合循环使用，就是不断重复通过执行CAS指令，直到成功为止，当长时间进行CAS的自旋的时候，会引起CPU资源的大量消耗。</p>
</li>
<li><p>只能保证一个共享变量的原子操作：当只有一个共享变量进行CAS操作的时候，就可以进行自旋的CAS去进行原子操作，但是对多个共享变量进行CAS操作的时候，循环CAS无法保证原子性。这时候我们可以取巧将这两个变量放在一个对象里面，比如说把一个int按照高16位低16位分别保存两个变量，那么就可以完整的对这个对象及其引用做一个原子操作。从Java1.5之后，JDK提供的AtomicReference类可以用来保证对象之间的原子性。</p>
</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>volatile与CAS的配合我们在源码中会经常遇到，比如AQS、原子类等，所以深入了解这两个还是十分有必要的。后续也会写一些源码解析，当理解了volatile和CAS之后再去看源码，或许体验就不一样了～</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized的原理和使用</title>
    <url>/2020/02/05/synchronized%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>之前的文章主要结合例子介绍了一些概念性的东西，比如JMM，并发的三大问题等。从本文开始，将陆续介绍一些Java中同步机制。</p>
<p>本文主要介绍的是Java中的synchronized关键字，从使用入手，慢慢阐述其实现原理以及使用时候等注意事项。</p>
<a id="more"></a>

<h1 id="Java中的锁机制"><a href="#Java中的锁机制" class="headerlink" title="Java中的锁机制"></a>Java中的锁机制</h1><p>Java中的锁有很多，按照功能、种类进行分类，主要包括以下几种：</p>
<ol>
<li>从线程是否需要对资源加锁可以分为 <strong>悲观锁</strong> 和 <strong>乐观锁</strong>。</li>
<li>从锁的公平性进行区分，可以分为 <strong>公平锁</strong> 和 <strong>非公平锁</strong>。</li>
<li>从根据锁是否重复获取可以分为 可 <strong>重入锁</strong> 和 <strong>不可重入锁</strong>。</li>
<li>从那个多个线程能否获取同一把锁分为 <strong>共享锁</strong> 和 <strong>排他锁</strong>。</li>
</ol>
<p>而Java中的锁的具体实现主要有JVM提供的关键字synchronized和Java并发包下的Lock。</p>
<p>本文中介绍的synchronized如果按照上面的分类的话，应当属于 <strong>悲观锁、非公平锁、重入锁、排他锁</strong>。</p>
<h1 id="synchronized如何使用"><a href="#synchronized如何使用" class="headerlink" title="synchronized如何使用"></a>synchronized如何使用</h1><p>首先，我们来看看synchronized如何使用的。synchronized实现同步的基础是：Java中的每一个对象都可以作为锁。在使用的时候，主要有以下几种使用方式：</p>
<ol>
<li>修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">xxx</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//省略号</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">xxx</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//省略号</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object lock=<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">    <span class="comment">//省略号</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个线程试图访问同步代码块或者同步方法时，它必须先得到锁，退出或者抛出异常时必须释放锁。</p>
<p>现在我们从三大问题的角度来看，结合Java内存模型，看看synchronized是如何解决的：</p>
<ul>
<li><p>内存可见性：在进入同步代码块或者同步方法时，线程需要获取锁，JMM会把线程对应的工作内存置为无效。从而使得后续的共享变量必须从主内存中读取；在锁释放的时候，JMM会把线程对应的本地内存中的共享变量刷新到主内存中去。由于synchronized是排他锁，同一时刻，只有一个相关线程可以拿到对象上的锁，所以当每个线程执行时都会得到最新的变量，而执行完成后都会刷新主内存，因此能保证内存的可见性。</p>
</li>
<li><p>原子性：同步代码块或者同步方法的原子性并不是严格意义上的不可分割，事实上，在同步代码执行的过程中，也有可能被其他不相关的线程抢占。但是其他线程的运行结果并不影响持有锁的线程（如果有影响就要检查一下是否正确加锁了。。。）。同步代码原子性的保证，来自于其排他锁的性质。</p>
</li>
<li><p>重排序：同步代码块或者同步方法能够保证同步区域中的代码不跑到临界区外，<strong>但是不能保证同步区域内的代码不发生重排序（划重点！！）</strong>，如果说同步区域内的代码重排序，不影响后续线程的执行结果，那还好。但一旦出现这种情况，那么隐患还是相当大的，比如说单例模式的双重检查锁，需要靠volatile来修饰变量防止重排序。</p>
</li>
</ul>
<h1 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h1><p>之前说了很久的锁，那么Java中的对象锁是如何实现的？或者说，锁到底存放在哪里？</p>
<p>在《深入理解Java虚拟机一书中》，我们可以知道，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。Hotspot虚拟机的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针），数组会多1字宽(32位: 4字节)来存储数组长度。</p>
<p>synchronized用到的锁就是存在Java对象头当中的。其中Klass Point是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例；Mark Word用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键。</p>
<p>Mark Word主要用来存储对象自身的运行时数据，如hashcode、gc分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。mark word的位长度为JVM的一个Word大小，也就是说32位JVM的Mark word为32位，64位JVM为64位。在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。我们来看看它具体的结构和状态变化（以32位虚拟机为例）：</p>
<table>
<thead>
<tr>
<th align="center">锁状态</th>
<th align="center">30bit</th>
<th align="center">2bit锁标志位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">无锁状态</td>
<td align="center">对象的hashCode:25bit 对象分代年龄:4bit 是否是偏向锁:0</td>
<td align="center">01</td>
</tr>
<tr>
<td align="center">轻量级锁</td>
<td align="center">指向栈中锁记录的指针</td>
<td align="center">00</td>
</tr>
<tr>
<td align="center">重量级锁</td>
<td align="center">指向互斥量的指针</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">GC标记</td>
<td align="center">空</td>
<td align="center">11</td>
</tr>
<tr>
<td align="center">偏向锁</td>
<td align="center">线程ID:23bit 时间戳:2bit 对象分代年龄:4bit 是否是偏向锁:1</td>
<td align="center">01</td>
</tr>
</tbody></table>
<h1 id="Monitor机制"><a href="#Monitor机制" class="headerlink" title="Monitor机制"></a>Monitor机制</h1><p>在了解了锁的概念后，Java中又是如何实现同步获取锁的呢？这不得不提到Monitor机制，Monitor其实是一种同步工具、同步机制，在Java中，Object 类本身就是监视者对象，Java 对于 Monitor Object 模式做了内建的支持，即每一个Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质。并且同时只能有一个线程可以获得该对象monitor的所有权。在线程进入时通过monitorenter尝试取得对象monitor所有权，退出时通过monitorexit释放对象monitor所有权。</p>
<ul>
<li><p><strong>monitorenter</strong>过程如下：<br>如果<strong>monitor</strong>的进入数为0，则该线程进入<strong>monitor</strong>，然后将进入数设置为1，该线程即为<strong>monitor</strong>的所有者；<br>如果线程已经占有<strong>monitor</strong>，只是重新进入，则<strong>monitor</strong>的进入数+1（这也是重入锁的实现原理）；<br>如果其他线程已经占用<strong>monitor</strong>，则该线程处于阻塞状态，直至<strong>monitor</strong>的进入数为0，再重新尝试获得<strong>monitor</strong>的所有权。</p>
</li>
<li><p><strong>monitorexit</strong>过程如下：<br>执行<strong>monitorexit</strong>的线程必须是 object 所对应的<strong>monitor</strong>的所有者。执行指令时，<strong>monitor</strong>的进入数减1，如果减1后进入数为0，则线程退出 <strong>monitor</strong>，不再是这个<strong>monitor</strong>的所有者，其他被这个<strong>monitor</strong>阻塞的线程可以尝试获取这个<strong>monitor</strong>的所有权。</p>
</li>
</ul>
<h1 id="锁的底层优化"><a href="#锁的底层优化" class="headerlink" title="锁的底层优化"></a>锁的底层优化</h1><p>在Java早期版本中，synchronized属于重量级锁，效率低下，因为monitor是依赖于底层的操作系统的Mutex Lock来实现的，Java的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。</p>
<p>JDK1.6对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p>
<h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p>锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<h3 id="1-重量级锁"><a href="#1-重量级锁" class="headerlink" title="1.重量级锁"></a>1.重量级锁</h3><p>monitor监视器锁本质上是依赖操作系统的Mutex Lock互斥量 来实现的，我们一般称之为重量级锁。因为OS实现线程间的切换需要从用户态转换到内核态，这个转换过程成本较高，耗时相对较长，因此synchronized效率会比较低。 </p>
<h3 id="2-轻量级锁"><a href="#2-轻量级锁" class="headerlink" title="2.轻量级锁"></a>2.轻量级锁</h3><p>轻量级锁，其性能提升的依据是对于绝大部分的锁，在整个生命周期内都是不会存在竞争的，如果没有竞争，轻量级锁就可以使用CAS操作（乐观锁的一种实现，可以线程安全的修改变量，后续文章会讲到）避免互斥量的开销，从而提升效率。我们来看一下轻量级锁的获取和释放流程：</p>
<ul>
<li>轻量级锁的获取：</li>
</ul>
<ol>
<li>线程在进入到同步代码块的时候，JVM 会先在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象当前Mark Word的拷贝（官方称为 Displaced Mark Word），owner 指针指向对象的 Mark Word。如图所示</li>
</ol>
<p><img src="https://i.loli.net/2020/03/01/Nqvr4hlWdV26Xs5.jpg" alt="simpleLock.jpg"></p>
<ol start="2">
<li><p>JVM使用CAS操作尝试将对象头中的Mark Word更新为指向Lock Record的指针。如果更新成功，则执行步骤3；更新失败，则执行步骤4。</p>
</li>
<li><p>如果更新成功，那么这个线程就拥有了该对象的锁，对象的Mark Word的锁状态为轻量级锁（标志位转变为’00’）。此时线程堆栈与对象头的状态如图所示</p>
</li>
</ol>
<p><img src="https://i.loli.net/2020/03/01/Aper9L3jV4F8Is2.jpg" alt="simpleLock2.jpg"></p>
<ol start="4">
<li>如果更新失败，JVM首先检查对象的Mark Word是否指向当前线程的栈帧。如果是，就说明当前线程已经拥有了该对象的锁，那就可以直接进入同步代码块继续执行；如果不是，就说明这个锁对象已经被其他的线程抢占了，当前线程会尝试自旋一定次数来获取锁。如果自旋一定次数CAS操作仍没有成功，那么轻量级锁就要升级为重量级锁（锁的标志位转变为’10’），Mark Word 中存储的就是指向重量级锁的指针，后面等待锁的线程也就进入阻塞状态。</li>
</ol>
<ul>
<li>轻量级锁的释放：<br>通过CAS操作用线程中复制的DisplacedMark Word中的数据替换对象当前的Mark Word。如果替换成功，说明整个同步过程就完成了；如果替换失败，说明有其他线程尝试过获取该锁，并且此时锁已经是重量级锁，那就在释放锁的同时，唤醒被挂起的线程。</li>
</ul>
<h3 id="3-偏向锁"><a href="#3-偏向锁" class="headerlink" title="3.偏向锁"></a>3.偏向锁</h3><p>在一些情况下总是同一线程多次获得锁，此时第二次再重新做CAS修改对象头中的Mark Word这样的操作，有些多余。所以就有了偏向锁，只需要检查是否为偏向锁、锁标识为以及线程ID即可，只要是同一线程就不再修改对象头。其目的为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。</p>
<ul>
<li>偏向锁的获取：</li>
</ul>
<ol>
<li>检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01。</li>
<li>若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）。</li>
<li>如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行步骤（4）。</li>
<li>通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块。</li>
<li>执行同步代码块。</li>
</ol>
<ul>
<li>偏向锁的释放</li>
</ul>
<ol>
<li>当一个线程已经持有偏向锁，而另外一个线程尝试竞争偏向锁时，CAS替换线程ID操作失败，则开始撤销偏向锁。偏向锁的撤销，需要等待原持有偏向锁的线程到达全局安全点（在这个时间点上没有字节码正在执行），暂停该线程，并检查其状态。</li>
<li>如果原持有偏向锁的线程不处于活动状态或已退出同步代码块，则该线程释放锁。将对象头设置为无锁状态（锁标志位为’01’，是否偏向标志位为’0’）。</li>
<li>如果原持有偏向锁的线程未退出同步代码块，则升级为轻量级锁（锁标志位为’00’）</li>
</ol>
<h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>锁粗化就是 JVM 检测到一串零碎的操作都对同一个对象加锁，则会把加锁同步的范围粗化到整个操作序列的外部。</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>synchronized虽然能解决并发问题，但是也不能乱用。一方面过多的加锁会影响系统的性能，如果只需要保证内存可见性的话，用volatile效率会更高；另一方面如果锁加的不规范可能会导致死锁的发生。</p>
<p>但是即使我们正确的使用锁了，如果同步代码写的不好，也有一些隐患，请看下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Syn</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Object lock=<span class="keyword">new</span> Object();</span><br><span class="line">       Thread t1= <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                    System.out.println(<span class="string">"thread 1 : "</span>+Thread.currentThread().isInterrupted());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">       Thread t2= <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                    System.out.println(<span class="string">"thread 2 : "</span>+Thread.currentThread().isInterrupted());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">       t1.start();</span><br><span class="line">       t2.start();</span><br><span class="line"></span><br><span class="line">       Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">       <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">           t1.interrupt();</span><br><span class="line">           lock.notifyAll();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码的层面来看，最终结果应当是线程t1抛出异常，线程t2继续执行。但是事实真的如此吗？大家可以尝试一下～</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>synchronized是Java中十分重要的一个关键字，短短一篇文章很难把它说透彻。我也只不过是粗略的介绍了一下它的基本使用和原理，如有说的不对的地方，还请大家多多包涵hhhh～</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>内存可见性、原子性和重排序</title>
    <url>/2020/02/03/%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E9%87%8D%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>在上一篇文章中，笔者简单介绍了下<a href="https://karthurl.github.io/2020/02/29/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/" target="_blank" rel="noopener">Java内存模型</a>。本文承接上文，主要以代码+图片的形式呈现给大家，其主要目的是让大家对于并发程序中的内存可见性、原子性以及重排序有一定的了解。这三个问题也是并发程序为什么难写的原因。</p>
<a id="more"></a>
<h1 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h1><p>在说明什么是内存可见性之前，大家可以尝试运行下面的代码，看看结果如何。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Share</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag=<span class="keyword">false</span>; <span class="comment">//这是一个共享变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; <span class="comment">//新启一个线程</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!flag) &#123;  <span class="comment">//如果flag==true则跳出循环</span></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start(); <span class="comment">//启动线程</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);<span class="comment">//主线程sleep 1秒</span></span><br><span class="line">        flag=<span class="keyword">true</span>; <span class="comment">//将共享变量设置为true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按道理说，当主线程将共享变量设置为true之后，线程t应当跳出循环，程序结束。但事实上当我们运行这段代码后，即使过了几秒，程序仍没有结束，即线程t并没有感知到共享变量flag的变化。这就是一个内存可见性的问题，我们可以结合Java内存模型来理解这个问题，具体看下图。<br><img src="https://i.loli.net/2020/03/01/KT9WDUxStLqiVFd.jpg" alt="share.jpg"><br>看懂了这张图，那么产生内存可见性的原因就显而易见了。所有的共享变量存在于主内存中，每个线程有自己的工作内存，当一个线程将工作内存中的共享变量副本修改后，此时主内存和其他线程工作内存里的共享变量依然是旧值。结合例子，当主线程修改flag为true时，改变的仅仅是主线程工作内存中的flag值，而线程t的工作内存中flag值依然为false，所以仍旧在死循环中。这就是并发下的一个内存可见性的原因。</p>
<p>这里再啰嗦一下，JMM只是一个抽象，如果想知道更底层的原因，需要一些操作系统的知识。线程间的对于共享变量的可见性问题不是直接由多核引起的，而是由多缓存引起的。如果每个核心共享同一个缓存，那么也就不存在内存可见性问题了。现代多核CPU中每个核心拥有自己的一级缓存或一级缓存加上二级缓存等，问题就发生在每个核心的独占缓存上。每个核心都会将自己需要的数据读到独占缓存中，数据修改后也是写入到缓存中，然后等待刷入到主存中。所以会导致有些核心读取的值是一个过期的值。这里说的工作内存并不是真的是一块给每个线程分配的内存，而是JMM的一个抽象，是对于寄存器、一级缓存、二级缓存等的抽象。</p>
<h1 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h1><p>同样的我们尝试运行下面的代码。在这段代码中，我们用volatile关键字修饰了共享变量num，可以解决内存可见性问题（关于为什么volatile关键字可以解决内存可见性后面会有专门对文章解释，这里只需要知道就ok了）。我们来看一下这段代码的结果如何。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Atomic</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> num=<span class="number">0</span>; <span class="comment">//这是一个volatile修饰的共享变量，可以解决内存可见性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; <span class="comment">//新启一个线程</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">                    num++;   <span class="comment">//对num进行自增1操作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; <span class="comment">//新启另一个线程</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">                    num++;   <span class="comment">//对num进行自增1操作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start(); <span class="comment">//启动这两个线程</span></span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行几次的结果可能不尽相同，但是都不会是2000。<br>按道理来说，两个线程分别对<strong>num</strong>进行了1000次自增操作，而每次自增的结果都对其他线程是可见的，所以最后<strong>num</strong>应当等于2000才对啊，为什么会出现这种情况？</p>
<p>出现这种情况的关键代码是 <strong>num++</strong>。原因在于 <strong>++</strong>这一操作并非是原子操作。所谓原子操作，意思是“不可被中断的一个或一系列操作”，也就是说这单个或多个操作要么一次性执行完，要么不执行，不存在执行到一半被人插队。我们可以将 <strong>++</strong> 操作其拆分为三步来看：</p>
<ol>
<li><p>从内存中读取共享变量num到寄存器中</p>
</li>
<li><p>寄存器进行自增</p>
</li>
<li><p>将自增后到值写会内存中</p>
</li>
</ol>
<p>这三步中每一步单独的操作都是原子操作，但是这三个操作中间是可以被中断分离开的。我们可以看下面这张表格来直观的感受下。</p>
<table>
<thead>
<tr>
<th align="left">线程1</th>
<th align="left">线程2</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1.读取num，此时线程1中num=0</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2.寄存器对num进行自增，此时线程1中num=1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">1.线程1被挂起，线程2开始执行，读取num，由于线程1中的num还未刷新到主内存中，所以此时线程2中num=0</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">2.寄存器对num进行自增，此时线程2中num=1</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">3.将num写回到内存中去，此时内存中num=1</td>
</tr>
<tr>
<td align="left">3.将线程1中的num写回内存中去，此时内存中num=1</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>我们可以看到，尽管两个线程分别进行了一次自增操作，尽管我们保证了内存可见性，但是由于线程调度的原因，导致线程1的一些列操作被中断，从而最终导致所得的结果与我们预期不符。这就是并发的原子性问题。</p>
<h1 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h1><p>同样的我们还是通过代码看问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reorder</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            x = <span class="number">0</span>; y = <span class="number">0</span>; z = <span class="number">0</span>;</span><br><span class="line">            a = <span class="number">0</span>; b = <span class="number">0</span>; c = <span class="number">0</span>;</span><br><span class="line">            CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    latch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                a = <span class="number">1</span>;</span><br><span class="line">                b = <span class="number">1</span>;</span><br><span class="line">                c = <span class="number">1</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    latch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                z = c;</span><br><span class="line">                y = b;</span><br><span class="line">                x = a;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">            latch.countDown();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//等两个线程执行完后执行主线程 ps：join方法底层调用wait（）有释放锁的语义，可以保证所有的执行结果对主线程可见</span></span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line"></span><br><span class="line">            String result = <span class="string">"第"</span> + i + <span class="string">"次 ("</span> + x + <span class="string">","</span> + y +<span class="string">","</span> + z+ <span class="string">"）"</span>;</span><br><span class="line">            <span class="keyword">if</span>(z&gt;y||y&gt;x||z&gt;x) &#123;</span><br><span class="line">                System.err.println(result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们分析代码的逻辑，线程t1按次序分别将 <strong>a、b、c</strong> 三个赋值为1并写回到主内存，线程t2按次序分别读取 <strong>c、b、a</strong> 并赋值给 <strong>x、y、z</strong> 即使考虑到内存可见性的影响，如果上述步骤是按次序执行的话，必然不会出现 <strong>z&gt;y||y&gt;x||z&gt;x</strong> 这类情况，因为能够读取到后一个值的新值，意味着之前的值也已经被刷新到主内存中去了，后续读的话应该也是会读到新值。</p>
<p>相信程序运行不了多久我们就能看到结果。程序产生了与我们预期不符的结果，其原因就在于发生了重排序。</p>
<p>所谓重排序是指编译器和处理器为了优化程序性能而对指令序列进行重排序的一种手段。当然这种重排序是需要遵循一定的规则的，例如：as-if-serial语义。as-if-serial语义的意思是：不管怎么重排序，<strong>单线程</strong> 程序的执行结果不能改变。为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，但前提是在<strong>单线程</strong>情况下。这也为编写单线程程序的程序员创建了一个幻觉：单线程程序是按照程序的顺序来执行的。</p>
<p>在这个例子中，可以看到，两个线程中，对变量的赋值是相互不依赖的，所以允许编译器或者处理器对其进行重排序。但是线程2对变量的赋值依赖于线程1中的变量abc，因此产生了问题。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文以三个例子来简单说明内存可见效、原子性以及重排序这三个问题。在平时并发实践中，这三个问题也是需要我们仔细考虑的。在后续的文章中，我会给出一些Java中的解决方案，例如synchronized、lock等，看看Java中是如何解决这三个问题的。</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型</title>
    <url>/2020/02/02/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>本文从Java内存模型开始，通过对内存模型的理解让大家对于并发中的内存可见性、原子性和重排序有一些自己的想法，为后续的Java并发编程打下基础。</p>
<p>阅读本文前，需要有一定的Java基础，最好还有一定的并发编程基础。</p>
<a id="more"></a>
<h1 id="前言：为何需要并发？"><a href="#前言：为何需要并发？" class="headerlink" title="前言：为何需要并发？"></a>前言：为何需要并发？</h1><p>在学习并发之前，我们需要明白为什么需要并发？并发能带来什么好处？</p>
<p>熟悉操作系统的读者应该知道，多任务处理在现代操作系统中几乎已经是一项必备的功能了。在大多数情况下，计算机CPU的运算速度与它的存储和通信子系统的速度差距太大了，大量的时间都花费在了IO、网络通信或者数据库上了。因此我们必须采取一些手段来“压榨”CPU的性能，确保CPU不会在大部分情况下处于空闲状态。此时，并发编程可以实现当某个线程阻塞在IO或者其他耗时操作时，操作系统调度其他线程来使用CPU，确保了CPU大部分时间处于一个工作状态。此外，在如今普遍多核CPU的情况下，单线程依旧只能运行在一个CPU上，其他CPU的资源就浪费了，而多线程的情况下，可以实现多条线程并行执行，大大提高了程序运行的效率。</p>
<p>总而言之，并发编程所带来的好处无疑是很多的，但是同样的，其也会带来一些弊端。多线程并发运行给执行过程带来了很多不确定性，因为只有同一个线程内部代码的执行顺序是固定的，而不同线程之间的代码执行顺序无法确定。当多个线程之间互相干扰时，问题就会接踵而至。编写多线程代码时，如果没有考虑全面很容易产生概率性的、难以复现的Bug。系统进行线程上下文切换时会消耗少量的系统资源，过多的线程反而会使得系统性能下降。因此如何编写出高性能的并发程序变得至关重要。</p>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>在正式学习并发编程之前，我们需要明白并发编程可能会出现哪些问题，而理解这些问题的基础就是理解Java的内存模型。</p>
<h2 id="1-内存模型概述"><a href="#1-内存模型概述" class="headerlink" title="1.内存模型概述"></a>1.内存模型概述</h2><p>在过去，主流程序语言（如C和C++等）直接使用物理硬件和操作系统的内存模型。因此，由于不同平台上内存模型的差异，可能导致程序在一套平台上并发完全正常，而在另一套平台上并发访问出错，所以在某些场景下必须针对不同的平台来编写程序。</p>
<p>Java内存模型（Java Memory Model，简称JMM）是Java虚拟机规范定义的，用来屏蔽掉java程序在各种不同的硬件和操作系统对内存的访问的差异，这样就可以实现java程序在各种不同的平台上都能达到内存访问的一致性。JMM本质上是一套抽象的模型，并非真实存在，我们可以通过下图来直观的了解其结构。</p>
<p><img src="https://i.loli.net/2020/02/29/5sIWqJBjxgYFdQf.jpg" alt="JMM.jpg" title="Java内存模型"></p>
<p>可以看到JMM主要分为三块，分别是：主内存、工作内存和线程。主内存被所有线程共享，而工作内存是线程私有的，不被其他线程可见。下面我们来理解主内存和工作内存。</p>
<h2 id="2-主内存与工作内存"><a href="#2-主内存与工作内存" class="headerlink" title="2.主内存与工作内存"></a>2.主内存与工作内存</h2><p>首先需要强调的是，这里讲的主内存和工作内存与JVM内存区域中的Java堆，栈、方法区等并不是同一个层次的对内存的划分，这两者之间严格来讲几乎没什么关系。在这个基础上，我们接着去理解主内存和工作内存中到底存放着什么。<br><img src="https://i.loli.net/2020/02/29/kvcz68oSr3s7X4A.jpg" alt="主内存和工作内存.jpg"><br>从图中可以直观的了解到，线程之间的共享变量（包括实例字段、静态字段和构成数组对象的元素等）均存储在主内存中，而线程工作时所读/写读共享变量为工作内存中读共享变量副本。JMM规定了规定了线程对变量对所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p>
<h2 id="3-内存之间的操作"><a href="#3-内存之间的操作" class="headerlink" title="3.内存之间的操作"></a>3.内存之间的操作</h2><p>那么问题来了，工作内存是如何从主内存拷贝数据，主内存又是如何更新数据的呢？JMM中定义了一下八种操作：</p>
<ul>
<li>Lock（锁定）：    作用于主内存变量，将变量标志为一条线程所独占</li>
<li>Unlock（解锁）：    作用于主内存变量，将处于锁定的变量释放出来</li>
<li>Read（读取）：    作用于主内存变量，它将一个变量的值从主内存传输到线程的工作内存中</li>
<li>Load（载入）：    作用于工作内存变量，它把从主内存读取的变量值放入工作内存的副本中</li>
<li>Use（使用）：    作用于工作内存变量，将工作内存变量值传递给执行引擎</li>
<li>Assgin（赋值）：    作用于工作内存变量，将执行引擎的值传递给工作内存的变量</li>
<li>Store（存储）：    作用于工作内存变量，它把工作内存变量传递到主内存中</li>
<li>Write（写入）：    作用于主内存变量，把Store操作从工作内存得到的变量值放入主内存变量中</li>
</ul>
<p>Java虚拟机实现时必须保证上面提及等每一种操作都是原子的、不可再分的（对于double和long类型的变量来说，load、store、read和write在某些平台上可能会有例外）。<br>如果要把一个变量的值从主内存复制到工作内存，那么需要执行read load操作；如果要把一个变量的值从工作内存同步回主内存，那么需要执行store write操作。但是JMM<strong>只能保证2个操作必须顺序执行，但不保证连续执行，即在指令之间可以插入其它指令</strong>。</p>
<p>除此之外，JMM还规定了在执行上述8种基本操作是必须满足如下规则：</p>
<ul>
<li>不允许read、load、store、write单独出现，即不允许一个变量读取到工作内存，但没有变量接收的情况</li>
<li>不允许一个线程丢弃它的assign操作，即变量在工作内存改变必须同步回主内存</li>
<li>不允许一个线程无原因（没有发生assgin赋值操作）把数据从线程的工作内存同步会主内存</li>
<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用未被初始化的变量</li>
<li>一个变量同一时刻只允许一条线程对其进行Lock锁定，但Lock操作可以被同一线程重复执行</li>
<li>如果对一个变量执行Lock锁定，会清空工作内存中该副本的值，即执行引擎使用该值会重新load assgin操作初始化该值</li>
<li>如果一个变量事先没有被Lock锁定，那就不允许进行Unlock操作，也不允许Unlock其它线程锁定的变量</li>
<li>对一个变量执行Unlock操作，必须先把此变量值同步回主内存（store、write操作）</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Java内存模型其实并不难理解，但并不意味着它不重要。相信大家看完本文后，通过对JMM的理解，对于为什么多线程会出现内存可见性，原子性以及重排序会有自己的想法。</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>原创</tag>
      </tags>
  </entry>
</search>
